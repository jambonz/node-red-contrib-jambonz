<!-- speech helpers -->
<script type="text/javascript">
  "use strict";

  let mapGoogle = {};
  let googleLanguageOptions = '';
  let mapAws = {};
  let awsLanguageOptions = '';
  //let mapSpeechRec = {};
  let sttLanguagesGoogle = '';
  let sttLanguagesAws = '';
  let mapDialogflow = {};
  let dialogFlowOptions = '';

  var googleUrl = (RED.settings.httpNodeRoot || RED.settings.httpAdminRoot || "").replace(/\/$/, "") + '/googleTts';
  $.getJSON(googleUrl, function (data) {
    //console.log('retrieved data ' + JSON.stringify(data));
    data.forEach(function(l) {
      mapGoogle[l.code] = {
        name: l.name,
        voices: l.voices
      };
      googleLanguageOptions += `<option value="${l.code}">${l.name}</option>`;        
    });
  });
  var awsUrl = (RED.settings.httpNodeRoot || RED.settings.httpAdminRoot || "").replace(/\/$/, "") + '/awsTts';
  $.getJSON(awsUrl, function (data) {
    //console.log('retrieved data ' + JSON.stringify(data));
    data.forEach(function(l) {
      mapAws[l.code] = {
        name: l.name,
        voices: l.voices
      };
      awsLanguageOptions += `<option value="${l.code}">${l.name}</option>`;        
    });
  });
  var googleSttUrl = (RED.settings.httpNodeRoot || RED.settings.httpAdminRoot || "").replace(/\/$/, "") + '/googleSpeech';
  $.getJSON(googleSttUrl, function (data) {
    //console.log('retrieved data for recognizer voices: ' + JSON.stringify(data));
    data.forEach(function(l) {
      //mapSpeechRec[l.code] = l.name;
      sttLanguagesGoogle += `<option value="${l.code}">${l.name}</option>`;        
    });
  });
  var awsSttUrl = (RED.settings.httpNodeRoot || RED.settings.httpAdminRoot || "").replace(/\/$/, "") + '/awsSpeech';
  $.getJSON(awsSttUrl, function (data) {
    //console.log('retrieved data for recognizer voices: ' + JSON.stringify(data));
    data.forEach(function(l) {
      //mapSpeechRec[l.code] = l.name;
      sttLanguagesAws += `<option value="${l.code}">${l.name}</option>`;        
    });
  });

  var dialogflowUrl = (RED.settings.httpNodeRoot || RED.settings.httpAdminRoot || "").replace(/\/$/, "") + '/dialogflow';
  $.getJSON(dialogflowUrl, function (data) {
    console.log('retrieved data for dialogflow languages: ' + JSON.stringify(data));
    data.forEach(function(l) {
      mapDialogflow[l.code] = l.name;
      dialogFlowOptions += `<option value="${l.code}">${l.name}</option>`;        
    });
  });

  function testCredentials() {
    const baseUrl =  $("#node-config-input-url").val();
    const accountSid =  $("#node-config-input-accountSid").val();
    const token =  $("#node-config-input-apiToken").val();
    const status = $("#node-config-test-status");

    status.text('');

    $.ajax({
      url: `${baseUrl}/v1/Accounts/${accountSid}/ApiKeys`,
      headers: {
        'Authorization': `Bearer ${token}`
      },
      dataType: 'json',
      timeout: 500,
      error: (err) => {
        status.text('Failed');
        console.log(err);
      },
      success: (res) => {
        if (Array.isArray(res)) status.text('Success!');
        else status.text('Failed');
        console.log(`response from fetch of api keys: ${JSON.stringify(res)}`);
      }
    });
  }

  function prepareSttControls(node) {
    var vendorElem = $('#node-input-transcriptionvendor');
    var languageElem = $('#node-input-recognizerlang');
    var mixtypeElem = $('#node-input-mixtype');

    console.log('entering prepareSttControls');
    
    var setTranscriptionLanguage = function(vendor) {
      console.log(`setting transcription vendor to ${vendor}`);
      languageElem.find('option').remove();
      switch (vendor) {
        case 'google':
          languageElem.append('<option value="default">--application default--</option>');
          languageElem.append(sttLanguagesGoogle);
          $('#google-stt-options').show();
          $('#aws-stt-options').hide();
          $('#interim').show();
          if (node.mixtype === 'stereo') $('#stt-identify-channels').show();
          else  $('#stt-identify-channels').hide();
          break;
        case 'aws':
          languageElem.append('<option value="default">--application default--</option>');
          languageElem.append(sttLanguagesAws);
          $('#google-stt-options').hide();
          $('#aws-stt-options').show();
          $('#interim').show();
          if (node.mixtype === 'stereo') $('#stt-identify-channels').show();
          else  $('#stt-identify-channels').hide();
          break
        default:
          languageElem.append('<option value="default">--application default--</option>');
          node.transcriptionvendor = 'default';
          $('#google-stt-options').hide();
          $('#aws-stt-options').hide();
          $('#stt-identify-channels').hide();
          $('#interim').hide();
          break;
      }
    }

    var onVendorChanged = function() {
      var vendor = vendorElem.find(':selected').val();
      console.log(`stt vendor changed to ${node.transcriptionvendor}`);
      setTranscriptionLanguage(vendor);
      if (vendor === 'default') node.recognizerlang = 'default';
      console.log(`initializing transcription language to ${node.recognizerlang}`);
      languageElem.val(node.recognizerlang);
    }
  
    var onLangChanged = function() {
      var lang = languageElem.find(':selected').val();
      console.log(`lang dropdown changed to ${lang}`);
      node.recognizerlang = lang;
    }

    var onMixtypeChange = function() {
      var mix = mixtypeElem.find(':selected').val();
      console.log(`mixtype is now ${mix}`);
      if (mix === 'stereo') $('#stt-identify-channels').show();
      else  $('#stt-identify-channels').hide();
    }

    vendorElem.change(onVendorChanged);
    languageElem.change(onLangChanged);
    mixtypeElem.change(onMixtypeChange);

    console.log(`initializing transcription vendor to ${node.transcriptionvendor}`);
    vendorElem.val(node.transcriptionvendor);

  }

  function prepareTtsControls(node) {
    var vendorElem = $('#node-input-vendor');
    var langElem = $('#node-input-lang');
    var xlangElem = $('#node-input-xlang');
    var voiceElem = $('#node-input-voice');
    var xvoiceElem = $('#node-input-xvoice');
  
    console.log(`oneditprepare tts vendor: ${node.vendor}, lang: ${node.lang}, voice: ${node.voice}`);

    var onVendorChanged = function() {
      node.vendor = vendorElem.val();
      console.log(`tts vendor changed to ${node.vendor}`);
      setLanguage(node.vendor);
    }
    var setLanguage = function(v) {
      xlangElem.find('option').remove();
      xvoiceElem.find('option').remove();

      switch (v) {
        case 'default': 
          xlangElem.append('<option value="default" selected>--application default--</option>');
          xvoiceElem.append('<option value="default" selected>--application default--</option>');
          langElem.val('default');
          voiceElem.val('default');
          break;

        case 'google':
          xlangElem.append(googleLanguageOptions);
          break;

        case 'aws':
          xlangElem.append(awsLanguageOptions);
          break;
      }
      console.log(`installed language choices for ${v}`);
      xlangElem.val(langElem.val());
    }
    var onLangChanged = function() {
      console.log(`lang edit changed to ${langElem.val()}`);
    }
    var onXLangChanged = function() {
      var lang = xlangElem.find(':selected').val();
      console.log(`lang dropdown changed to ${lang}`);
      node.lang = lang;
      langElem.val(node.lang);
      setVoice(node.vendor, node.lang)
    }
    var setVoice = function(vendor, lang) {
      xvoiceElem.find('option').remove();

      console.log(`installing voices for ${vendor} ${lang}`);
      switch (vendor) {
        case 'default':
          xvoiceElem.append('<option value="default" selected>--application default--</option>');
          break;

        case 'google':
        case 'aws':
          var obj = 'google' === vendor ? mapGoogle[lang] : mapAws[lang];
          if (obj) {
            var options = '';
            for (var i = 0; i < obj.voices.length; i++) {
              if (i) options += `<option value="${obj.voices[i].value}">${obj.voices[i].name}</option>`;
              else options += `<option value="${obj.voices[i].value}">${obj.voices[i].name}</option>`;
            }
            xvoiceElem.append(options);
          }
          break;
      }
      console.log(`installed voice choices for ${vendor} ${lang}`);
      if (voiceElem.val()) xvoiceElem.val(voiceElem.val());
    }
    var onVoiceChanged = function() {
      console.log(`voice edit changed to ${voiceElem.val()}`);
      xvoiceElem.val(voiceElem.val());
    }
    var onXVoiceChanged = function() {
      var voice = xvoiceElem.find(':selected').val();
      node.voice = voice;
      console.log(`voice dropdown changed to ${voice}`);
      voiceElem.val(voice);
    }

    vendorElem.change(onVendorChanged);
    langElem.change(onLangChanged);
    xlangElem.change(onXLangChanged);
    voiceElem.change(onVoiceChanged);
    xvoiceElem.change(onXVoiceChanged);
  }

  RED.nodes.registerType('user auth',{
      category: 'jambonz',
      color:"#c1f986",
      defaults: {
        name: {value: ''},
        password: {},
        passwordType: {},
        ha1: {},
        ha1Type: {}
      },
      inputs:1,
      outputs:1,
      icon: "font-awesome/fa-id-badge",
      label: function() { return this.name || 'user auth';},
      oneditprepare: function() {
        $('#node-input-password').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-passwordType')
        });
        $('#node-input-ha1').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-ha1Type')
        });
      }
  });

  RED.nodes.registerType('conference',{
    category: 'jambonz',
    color: '#bbabaa',
    defaults: {
      name: {value: ''},
      conference: {required: true, value: ''},
      conferenceType: {value: 'str'},
      beep: {value: false},
      endConferenceOnExit: {value: false},
      startConferenceOnEnter: {value: false},
      maxParticipants: {},
      maxParticipantsType: {value: 'num'},
      enterHook: {},
      enterHookType: {value: 'str'},
      waitHook: {},
      waitHookType: {value: 'str'},
      joinMuted : {value: false}
    },
    inputs:1,
    outputs:1,
    icon: "font-awesome/fa-cubes",
    label: function() { 
      return this.name || 'conference';
    },
    oneditprepare: function() {
      $('#node-input-conference').typedInput({
        types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
        typeField: $('#node-input-conferenceType')
      });
      $('#node-input-enterHook').typedInput({
        types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
        typeField: $('#node-input-enterHookType')
      });
      $('#node-input-waitHook').typedInput({
        types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
        typeField: $('#node-input-waitHookType')
      });
      $('#node-input-maxParticipants').typedInput({
        types: ['num', 'msg', 'flow', 'global'],
        typeField: $('#node-input-maxParticipantsType')
      });
    }
  });

  RED.nodes.registerType('dequeue',{
      category: 'jambonz',
      color: '#bbabaa',
      defaults: {
        name: {value: ''},
        queue: {required: true, value: ''},
        queueType: {value: 'str'},
        actionHook: {},
        actionHookType: {value: 'str'},
        confirmHook: {},
        confirmHookType: {value: 'str'},
        beep: {value: false},
        timeout: {},
        timeoutType: {value: 'num'}
      },
      inputs:1,
      outputs:1,
      icon: "font-awesome/fa-cubes",
      label: function() { 
        return this.name || 'dequeue';
      },
      oneditprepare: function() {
        $('#node-input-queue').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-queueType')
        });
        $('#node-input-actionHook').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-actionHookType')
        });
        $('#node-input-confirmHook').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-confirmHookType')
        });
        $('#node-input-timeout').typedInput({
          types: ['num', 'msg', 'flow', 'global'],
          typeField: $('#node-input-timeoutType')
        });
      }
  });

  RED.nodes.registerType('dial',{
      category: 'jambonz',
      color: '#bbabaa',
      defaults: {
        name: {value: ''},
        targets:{value:[{type: 'phone', dest: '', user: '', pass: '', varType: 'str', trunk: ''}]},
        headers: {value: []},
        actionhook: {value: ''},
        actionhookType: {value: 'str'},
        answeronbridge: {value: false},
        callerid: {value: ''},
        calleridType: {value: ''},
        confirmhook: {value: ''},
        confirmhookType: {value: 'str'},
        dialmusic: {value: ''},
        dialmusicType: {value: 'str'},
        dtmfcapture: {value: ''},
        dtmfcaptureType: {value: 'str'},
        dtmfhook: {value: ''},
        dtmfhookType: {value: 'str'},
        timelimit: {validate:RED.validators.regex(/^\d*$/) },
        timeout: {validate:RED.validators.regex(/^\d*$/) },
        listenurl: {value: ''},
        listenurlType: {value: 'str'},
        transcriptionhook: {},
        transcriptionhookType: {value: 'str'},
        transcriptionvendor: {value: 'default'},
        recognizerlang: {value: 'default'},
        recognizeraltlang: {},
        recognizeraltlangType: {val: 'str'},
        interim: {value: false},
        profanityfilter: {value: false},
        transcriptionhints: {},
        transcriptionhintsType: {val: 'str'},
        separaterecog: {value: false},
        useenhanced: {value: false},
        words: {value: false},
        punctuation: {value: false},
        diarization: {value: false},
        diarizationmin: {value: 2},
        diarizationminType: {value: 'num'},
        diarizationmax: {value: 6},
        diarizationmaxType: {value: 'num'},
        interactiontype: {value: 'unspecified'},
        naics: {value: 0},
        naicsType: {value: 'num'},
        identifychannels: {value: false},
        speakerlabel: {value: false},
        vocabularyname: {},
        vocabularynameType: {value: 'str'},
        vocabularyfiltername: {},
        vocabularyfilternameType: {value: 'str'},
        vocabularyfiltermethod: {}
      },
      inputs:1,
      outputs:1,
      icon: "font-awesome/fa-cubes",
      label: function() { return this.name || 'dial';},
      oneditprepare: function() {
        var node = this;
        $('#node-input-callerid').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-calleridType')
        });
        $('#node-input-actionhook').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-actionhookType')
        });
        $('#node-input-confirmhook').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-confirmhookType')
        });
        $('#node-input-dialmusic').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-dialmusicType')
        });
        $('#node-input-dtmfcapture').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-dtmfcaptureType')
        });
        $('#node-input-dtmfhook').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-dtmfhookType')
        });
        $('#node-input-transcribeurl').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-transcribeurlType')
        });
        $('#node-input-listenurl').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-listenurlType')
        });
        $('#node-input-transcriptionhook').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-transcriptionhookType')
        });
        $('#node-input-transcriptionhints').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-transcriptionhintsType')
        });
        $('#node-input-recognizeraltlang').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-recognizeraltlangType')
        });
        $('#node-input-diarizationmin').typedInput({
          types: ['num', 'msg', 'flow', 'global'],
          typeField: $('#node-input-diarizationminType')
        });
        $('#node-input-diarizationmax').typedInput({
          types: ['num', 'msg', 'flow', 'global'],
          typeField: $('#node-input-diarizationmaxType')
        });
        $('#node-input-naics').typedInput({
          types: ['num', 'msg', 'flow', 'global'],
          typeField: $('#node-input-naicsType')
        });

        console.log('oneditprepare - dial');
        prepareSttControls(node);

        $('#node-input-target-container').css('min-height','180px').css('min-width','450px').editableList({
          addItem: function(container, i, opt) {
            var target = opt;
            console.log(`addItem: ${JSON.stringify(opt)}, keys ${Object.keys(opt).length}`);
            if (!target.hasOwnProperty('type')) {
              target = {
                type: 'phone',
                dest: '',
                user: '',
                pass: '',
                varType: 'str'
              };
            }

            container.css({
              overflow: 'hidden',
              whiteSpace: 'nowrap'
            });
            let fragment = document.createDocumentFragment();
            var row1 = $('<div/>',{style:"display:flex;"}).appendTo(fragment);
            var row2 = $('<div/>',{style:"display:flex;margin-top:8px;"}).appendTo(fragment);
            var row3 = $('<div/>',{style:"margin-top:8px;"}).appendTo(fragment);
            var row4 = $('<div/>',{style:"display:flex;margin-top:8px;"}).appendTo(fragment);
            var row5 = $('<div/>',{style:"margin-top:8px;"}).appendTo(fragment);

            var selectField = $('<select/>',{class:"node-input-target-type",style:"width:110px; margin-right:10px;"})
              .appendTo(row1);
            var selectOptions = ['phone', 'user', 'sip', 'teams'];
            for (var i = 0; i < 4; i++) {
                selectField.append($("<option></option>").val(selectOptions[i]).text(selectOptions[i]));
            }
            var propertyName = $('<input/>', {class:"node-input-target-property-name", type:"text"})
              .appendTo(row1)
              .typedInput({types: ['str', 'msg', 'flow', 'global']});

            $('<label style="padding-top:8px; padding-right:20px">Auth Username:</label>')
              .appendTo(row2);

            $('<input/>',{
              class:"node-input-target-property-authuser", 
              type:"text", 
              placeholder: '(if required by remote endpoint)'
            })
              .appendTo(row2);

            $('<label style="padding-top:8px; padding-right:20px">Auth Password:</label>')
              .appendTo(row3);
            $('<input/>',{
              class:"node-input-target-property-authpassword", 
              type:"text", 
              placeholder: '(if required by remote endpoint)'
            })
              .appendTo(row3);

            $('<label style="padding-top:8px; padding-right:20px">Trunk:</label>')
              .appendTo(row5);

            $('<input/>',{
              class:"node-input-target-property-trunk",
              type:"text",
              placeholder: 'Specify the name of the trunk used for this outbound call'
            })
              .appendTo(row5);
            
            selectField.on('change', function() {
              var type = $(this).val();
              console.log(`type changed to ${type}`);
              var input = $(this).parent().find('input.red-ui-typedInput-input');
              input.focus();
              switch (type) {
                case 'phone': 
                  input.attr('placeholder', 'E.164 number to dial');
                  break;
                case 'teams':
                  input.attr('placeholder', 'Microsoft Teams phone number or extension');
                  break;
                case 'user': 
                  input.attr('placeholder', 'user@domain');
                  break;
                case 'sip': 
                  input.attr('placeholder', 'sip:number@ip-address');
                  break;
              }
              if (type !== 'sip') {
                row2.hide();
                row3.hide();
              }
              else {
                row2.show();
                row3.show();
              }

              if(type !== 'phone') {
                row5.hide();
              } else {
                row5.show();
              }
            });
            selectField.val(target.type);
            propertyName.typedInput('value', target.dest);
            propertyName.typedInput('type', target.varType);

            var datafield = row1.find('.node-input-target-property-name');
            var userfield = row2.find('.node-input-target-property-authuser');
            var passfield = row3.find('.node-input-target-property-authpassword');
            var trunkfield = row5.find('.node-input-target-property-trunk');

            datafield.typedInput('type', target.varType);

            switch (target.type) {
              case 'phone':
                trunkfield.val(target.trunk);
              case 'sip': 
                userfield.val(target.user);
                passfield.val(target.pass);
              default:
                datafield.typedInput('value', target.dest);
                break;
            }
            selectField.change();
            container[0].appendChild(fragment);
          },
          removable: true,
          addButton: 'add target'
        });
        console.log(`oneditprepare: coming in with targets: ${JSON.stringify(this.targets)}`);
        if (!this.targets) {
          var target = {
            type: 'phone',
            dest: '',
            user: '',
            pass: '',
            trunk: '',
            varType: 'str'
          }
          this.targets = [target];
        }

        for (var i=0; i < this.targets.length; i++) {
            var target = this.targets[i];
            $("#node-input-target-container").editableList('addItem', target);
        }
        // populate headers editable list
        $('#node-input-headers-container').css('min-height','120px').css('min-width','450px').editableList({
          addItem: function(container, i, opt) {
            var header = opt;
            if (!header.hasOwnProperty('h')) {
                header = {h: '', v: ''};
            }
            container.css({
              overflow: 'hidden',
              whiteSpace: 'nowrap'
            });
            let fragment = document.createDocumentFragment();
            var row1 = $('<div/>',{style:"display:flex;"}).appendTo(fragment);
            $('<input/>', {
              class:"node-input-header-property-name", 
              type:"text", 
              placeholder: 'SIP Header'
            })
              .appendTo(row1);
            $('<input/>', {
              class:"node-input-value-property-name", 
              type:"text", 
              placeholder: 'value'
            })
              .appendTo(row1);

            row1.find('.node-input-header-property-name').val(header.h);
            row1.find('.node-input-value-property-name').val(header.v);

            container[0].appendChild(fragment);
          },
          removable: true
        });
        console.log(`oneditprepare: coming in with headers: ${JSON.stringify(this.headers)}`);
        if (!this.headers) {
          var header = {
            h: '',
            v: '',
          };
          this.headers = [header];
        }

        for (var i=0; i < this.headers.length; i++) {
            var header = this.headers[i];
            $("#node-input-headers-container").editableList('addItem', header);
        }
      },
      oneditsave: function () {
        var targets = $("#node-input-target-container").editableList('items');
        var node = this;
        node.targets = [];
        console.log(`entering oneditsave with ${targets.length} targets`);

        targets.each(function(i) {
          var target = $(this);
          var type = target.find('.node-input-target-type').val();
          var varType = target.find('.node-input-target-property-name').typedInput('type');
          var dest    = target.find('.node-input-target-property-name').typedInput('value');
          var user = target.find('.node-input-target-property-authuser').val();
          var pass = target.find('.node-input-target-property-authpassword').val();
          var trunk = target.find('.node-input-target-property-trunk').val();
          if (!['phone', 'user', 'sip', 'teams'].includes(type) || 0 === dest.length) return;

          var t = {
            type,
            varType,
            dest
          };
          if ('sip' === type && user.length > 0 && pass.length > 0) {
            Object.assign(t, {user, pass});
          }
          if ('phone' === type && trunk.length > 0) {
            t.trunk = trunk;
          }
          node.targets.push(t);
        });
        console.log(`saved targets ${JSON.stringify(node.targets)}`);

        var headers = [];
        $("#node-input-headers-container").editableList('items').each(function(i) {
          var header = $(this);
          console.log(`header: ${JSON.stringify(header)}`);
          var h = header.find(".node-input-header-property-name").val();
          var v = header.find(".node-input-value-property-name").val();
          console.log(`added ${h}: ${v}`);
          var obj = {};
          obj[h] = v;
          headers.push({h, v});
        });
        node.headers = headers;
        console.log(`saved headers ${JSON.stringify(node.headers)}`);
      },
    });

    RED.nodes.registerType('dialogflow',{
      category: 'jambonz',
      color: '#bbabaa',
      defaults: {
        name: {value: ''},
        recognizerlang: {value: 'en-US'},
        serviceAccountCredentials: {required: true, value: ''},
        serviceAccountCredentialsType: {value: 'msg'},
        project: {required: true, value: ''},
        projectType: {value: 'str'},
        environment: {value: ''},
        environmentType: {value: 'str'},
        welcomeEvent: {},
        welcomeEventType: {value: 'str'},
        welcomeEventParams: {},
        welcomeEventParamsType: {value: 'json'},
        passDtmf: {value: false},
        inputTimeout: {},
        inputTimeoutType: {value: 'num'},
        noInputEvent: {},
        noInputEventType: {value: 'str'},
        bargein: {value: false},
        eventHook: {},
        eventHookType: {value: 'str'},
        actionHook: {},
        actionHookType: {value: 'str'},
        evtAll: {value: true},
        evtIntent: {value: false},
        evtTranscript: {value: false},
        evtInterimTranscript: {value: false},
        evtDtmf: {value: false},
        evtEndUtterance: {value: false},
        evtStartPlay: {value: false},
        evtEndPlay: {value: false},
        evtNoInput: {value: false},
        prompt: {value: 'dialogflow', required: true},
        vendor: {value: 'default'},
        lang: {value: 'default'},
        voice: {value: 'default'},
        xlang: {},
        xvoice: {}
      },
      inputs:1,
      outputs:1,
      icon: "font-awesome/fa-cubes",
      label: function() { return this.name || 'dialogflow';},
      oneditprepare: function() {
        var node = this;
        $('#node-input-serviceAccountCredentials').typedInput({
          typeField: $('#node-input-serviceAccountCredentialsType'),
          types: ['json', 'msg', 'flow', 'global']
        });
        $('#node-input-project').typedInput({
          typeField: $('#node-input-projectType'),
          types: ['str','msg', 'flow', 'global']
        });
        $('#node-input-environment').typedInput({
          typeField: $('#node-input-environmentType'),
          types: ['str','msg', 'flow', 'global']
        });
        $('#node-input-welcomeEvent').typedInput({
          typeField: $('#node-input-welcomeEventType'),
          types: ['str','msg', 'flow', 'global']
        });
        $('#node-input-welcomeEventParams').typedInput({
          typeField: $('#node-input-welcomeEventParamsType'),
          types: ['json', 'msg', 'flow', 'global']
        });
        $('#node-input-eventHook').typedInput({
          typeField: $('#node-input-eventHookType'),
          types: ['str','msg', 'flow', 'global']
        });
        $('#node-input-actionHook').typedInput({
          typeField: $('#node-input-actionHookType'),
          types: ['str','msg', 'flow', 'global']
        });
        $('#node-input-inputTimeout').typedInput({
          typeField: $('#node-input-inputTimeout'),
          types: ['num','msg', 'flow', 'global']
        });
        $('#node-input-noinputEvent').typedInput({
          typeField: $('#node-input-noinputEventType'),
          types: ['str','msg', 'flow', 'global']
        });
        var promptElem = $('#node-input-prompt');
        var ttsDiv = $('#tts-options');
        var recLangElem = $('#node-input-recognizerlang');

        prepareTtsControls(node);
        var onPromptChanged = function () {
          node.action = promptElem.find(':selected').val();
          if ('tts' === node.action) ttsDiv.show();
          else ttsDiv.hide();
        }
        promptElem.change(onPromptChanged);

        var setTranscriptionLanguage = function() {
          console.log(`setting transcription languages: ${dialogFlowOptions}`);
          recLangElem.find('option').remove();
          recLangElem.append(dialogFlowOptions);
        }

        setTranscriptionLanguage();
        console.log(`setting lang to ${node.recognizerlang}`);
        recLangElem.val(node.recognizerlang);
      }
    });

    RED.nodes.registerType('enqueue',{
      category: 'jambonz',
      color: '#bbabaa',
      defaults: {
        name: {value: ''},
        queue: {required: true, value: ''},
        queueType: {value: 'str'},
        actionHook: {},
        actionHookType: {value: 'str'},
        waitHook: {},
        waitHookType: {value: 'str'}
      },
      inputs:1,
      outputs:1,
      icon: "font-awesome/fa-cubes",
      label: function() { 
        return this.name || 'enqueue';
      },
      oneditprepare: function() {
        $('#node-input-queue').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-queueType')
        });
        $('#node-input-actionHook').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-actionHookType')
        });
        $('#node-input-waitHook').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-waitHookType')
        });
      }
  });

  RED.nodes.registerType('gather',{
      category: 'jambonz',
      color: '#bbabaa',
      defaults: {
        name: {value: ''},
        actionhook: {value: ''},
        finishonkey: {value: ''},
        dtmfinput: {value: 0},
        speechinput: {value: 1},
        numdigits: {value: ''},
        timeout: {value: ''},
        prompttype: {value: 'say'},
        playurl: {value: ''},
        playurlType: {value: 'str'},
        text: {value: ''},
        vendor: {value: 'default'},
        lang: {value: 'default'},
        voice: {value: 'default'},
        xvoice: {},
        xlang: {},
        transcriptionvendor: {value: 'default'},
        recognizerlang: {value: 'default'},
        recognizeraltlang: {},
        recognizeraltlangType: {val: 'str'},
        interim: {value: false},
        profanityfilter: {value: false},
        transcriptionhints: {},
        transcriptionhintsType: {val: 'str'},
        separaterecog: {value: false},
        useenhanced: {value: false},
        words: {value: false},
        punctuation: {value: false},
        diarization: {value: false},
        diarizationmin: {value: 2},
        diarizationminType: {value: 'num'},
        diarizationmax: {value: 6},
        diarizationmaxType: {value: 'num'},
        interactiontype: {value: 'voice_command'},
        naics: {value: 0},
        naicsType: {value: 'num'},
        identifychannels: {value: false},
        speakerlabel: {value: false},
        vocabularyname: {},
        vocabularynameType: {value: 'str'},
        vocabularyfiltername: {},
        vocabularyfilternameType: {value: 'str'},
        vocabularyfiltermethod: {}
      },
      inputs:1,
      outputs:1,
      icon: "font-awesome/fa-cubes",
      label: function() { return this.name || 'gather';},
      oneditprepare: function() {
        var node = this;
        prepareTtsControls(node);
        prepareSttControls(node);

        $('#node-input-playurl').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-playurlType')
        });
        $('#node-input-transcriptionhints').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-transcriptionhintsType')
        });
        $('#node-input-recognizeraltlang').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-recognizeraltlangType')
        });
        $('#node-input-naics').typedInput({
          types: ['num', 'msg', 'flow', 'global'],
          typeField: $('#node-input-naicsType')
        });

        var enableSpeech = function(enabled) {
          console.log(`enable speech: ${enabled}`);
          if (enabled) $('#speech-input-container').show();
          else $('#speech-input-container').hide();
        }
        var enableDtmf = function(enabled) {
          console.log(`enable dtmf: ${enabled}`);
          if (enabled) $('#dtmf-input-container').show();
          else $('#dtmf-input-container').hide();          
        }

        $('#node-input-speechinput').change(function() {
          var doSpeech = $('#node-input-speechinput:checked').val();
          enableSpeech(doSpeech);
        });
        $('#node-input-dtmfinput').change(function() {
          var doDtmf = $('#node-input-dtmfinput:checked').val();
          enableDtmf(doDtmf);
        });

        var onSayPlayChanged = function () {
          var type = $('#node-input-prompttype').find(':selected').val();
          console.log(`prompt type changed to ${type}`);
          if (type === 'say') {
            $('#say-container').show();
            $('#play-container').hide();
          }
          else {
            $('#play-container').show();
            $('#say-container').hide();
          }
        }

        $('#node-input-prompttype').change(onSayPlayChanged);
      }
  });

  RED.nodes.registerType('hangup',{
      category: 'jambonz',
      color: '#bbabaa',
      defaults: {
        name: {value: ''},
      },
      inputs:1,
      outputs:1,
      icon: "font-awesome/fa-cubes",
      label: function() { return this.name || 'hangup';},
  });

  RED.nodes.registerType('leave',{
      category: 'jambonz',
      color: '#bbabaa',
      defaults: {
        name: {value: ''},
      },
      inputs:1,
      outputs:1,
      icon: "font-awesome/fa-cubes",
      label: function() { return this.name || 'leave';}
  });

  RED.nodes.registerType('lex',{
      category: 'jambonz',
      color: '#bbabaa',
      defaults: {
        name: {value: ''},
        aws: {value: '', type: 'aws_auth'},
        bot: {required: true},
        botType: {value: 'str'},
        alias: {required: true},
        aliasType: {value: 'str'},
        region: {required: true, value: 'us-east-1'},
        locale: {value: 'en_US'},
        localeType: {value: 'str'},
        specifyIntent: {value: true},
        intent: {value: ''},
        intentType: {value: 'str'},
        slots: {value: ''},
        slotsType: {value: 'json'},
        metadata: {value: ''},
        metadataType: {value: 'json'},
        welcomeMessage: {value: 'str'},
        eventHook: {},
        eventHookType: {value: 'str'},
        actionHook: {},
        actionHookType: {value: 'str'},
        bargein: {value: true},
        inputTimeout: {},
        inputTimeoutType: {value: 'num'},
        passDtmf: {value: true},
        prompt: {value: 'lex', required: true},
        vendor: {value: 'default'},
        lang: {value: 'default'},
        voice: {value: 'default'},
        xlang: {},
        xvoice: {}
      },
      inputs:1,
      outputs:1,
      icon: "font-awesome/fa-cubes",
      label: function() { return this.name || 'lex';},
      oneditprepare: () => {
        var node = this;
        var promptElem = $('#node-input-prompt');
        var ttsDiv = $('#tts-options');

        prepareTtsControls(node);

        $('#node-input-bot').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-botType')
        });
        $('#node-input-alias').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-aliasType')
        });
        $('#node-input-locale').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-localeType')
        });
        $('#node-input-intent').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-intentType')
        });
        $('#node-input-inputTimeout').typedInput({
          types: ['num', 'msg', 'flow', 'global'],
          typeField: $('#node-input-inputTimeoutType')
        });
        $('#node-input-slots').typedInput({
          typeField: $('#node-input-slotsType'),
          types: ['json', 'msg', 'flow', 'global']
        });
        $('#node-input-metadata').typedInput({
          typeField: $('#node-input-metadataType'),
          types: ['json', 'msg', 'flow', 'global']
        });

        var onPromptChanged = function () {
          node.action = promptElem.find(':selected').val();
          if ('tts' === node.action) ttsDiv.show();
          else ttsDiv.hide();
        }

        promptElem.change(onPromptChanged);
        $('#node-input-specifyIntent').change(function() {
          const doIntent = $('#node-input-specifyIntent:checked').val();
          console.log('intent? ' + doIntent);
          if (doIntent) {
            $('#intent-options').show();
            $('#welcome-msg-options').hide();
          }
          else {
            $('#intent-options').hide();
            $('#welcome-msg-options').show();
          }
        });
      }
  });

  RED.nodes.registerType('listen',{
      category: 'jambonz',
      color: '#bbabaa',
      defaults: {
        name: {value: ''},
        actionhook: {},
        actionhookType: {value: 'str'},
        url: {required: true},
        urlType: {value: 'str'},
        authuser: {},
        authuserType: {val: 'str'},
        authpass: {},
        authpassType: {val: 'str'},
        finishonkey: {},
        maxlength: {},
        metadata: {},
        metadataType: {value: 'json'},
        mixtype: {value: 'mono'},
        beep: {value: false},
        samplerate: {value: 8000},
        timeout: {},
        transcriptionhook: {},
        transcriptionhookType: {value: 'str'},
        transcriptionvendor: {value: 'default'},
        recognizerlang: {value: 'default'},
        recognizeraltlang: {},
        recognizeraltlangType: {val: 'str'},
        interim: {value: false},
        profanityfilter: {value: false},
        transcriptionhints: {},
        transcriptionhintsType: {val: 'str'},
        separaterecog: {value: false},
        useenhanced: {value: false},
        words: {value: false},
        punctuation: {value: false},
        diarization: {value: false},
        diarizationmin: {value: 2},
        diarizationminType: {value: 'num'},
        diarizationmax: {value: 6},
        diarizationmaxType: {value: 'num'},
        interactiontype: {value: 'unspecified'},
        naics: {value: 0},
        naicsType: {value: 'num'},
        identifychannels: {value: false},
        speakerlabel: {value: false},
        vocabularyname: {},
        vocabularynameType: {value: 'str'},
        vocabularyfiltername: {},
        vocabularyfilternameType: {value: 'str'},
        vocabularyfiltermethod: {}
      },
      inputs:1,
      outputs:1,
      icon: "font-awesome/fa-cubes",
      label: function() { return this.name || 'listen';},
      oneditprepare: function() {
        var node = this;
        $('#node-input-actionhook').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-actionhookType')
        });
        $('#node-input-url').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-urlType')
        });
        $('#node-input-authuser').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-authuserType')
        });
        $('#node-input-authpassword').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-authpasswordType')
        });
        $('#node-input-metadata').typedInput({
          types: ['json', 'msg', 'flow', 'global'],
          typeField: $('#node-input-metadataType')
        });
        $('#node-input-transcriptionhook').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-transcriptionhookType')
        });
        $('#node-input-transcriptionhints').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-input-transcriptionhintsType')
        });
        $('#node-input-recognizeraltlang').typedInput({
          types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
          typeField: $('#node-recognizeraltlangType')
        });
        $('#node-input-diarizationmin').typedInput({
          types: ['num', 'msg', 'flow', 'global'],
          typeField: $('#node-input-diarizationminType')
        });
        $('#node-input-diarizationmax').typedInput({
          types: ['num', 'msg', 'flow', 'global'],
          typeField: $('#node-input-diarizationmaxType')
        });
        $('#node-input-naics').typedInput({
          types: ['num', 'msg', 'flow', 'global'],
          typeField: $('#node-input-naicsType')
        });

        prepareSttControls(node);
      }
  });

  RED.nodes.registerType('message', {
    category: 'jambonz',
    color: '#bbabaa',
    defaults: {
      name: {value: ''},
      from: {value: '', required: true},
      fromType: {value: ''},
      to: {value: '', required: true},
      toType: {value: ''},
      text: {value: '', required: true},
      textType: {value: ''},
      provider: {value: ''},
      providerType: {value: ''},
    },
    inputs:1,
    outputs:1,
    icon: "font-awesome/fa-cubes",
    label: function() { 
      return this.name || 'message';
    },
    oneditprepare: function() {
      var node = this;

      $('#node-input-from').typedInput({
        default: $('#node-input-fromType').val(),
        types: ['str','msg', 'flow', 'global'],
        typeField: $('#node-input-fromType')
      });
      $('#node-input-to').typedInput({
        default: $('#node-input-toType').val(),
        types: ['str','msg', 'flow', 'global'],
        typeField: $('#node-input-toType')
      });
      $('#node-input-text').typedInput({
        default: $('#node-input-textType').val(),
        types: ['str','msg', 'flow', 'global'],
        typeField: $('#node-input-textType')
      });
      $('#node-input-provider').typedInput({
        default: $('#node-input-providerType').val(),
        types: ['str','msg', 'flow', 'global'],
        typeField: $('#node-input-providerType')
      });
    }
  });

  RED.nodes.registerType('pause',{
      category: 'jambonz',
      color: '#bbabaa',
      defaults: {
        name: {value: ''},
        len: {required: true},
        lenType: {value: 'num'},

      },
      inputs:1,
      outputs:1,
      icon: "font-awesome/fa-cubes",
      label: function() { return this.name || 'pause';},
      oneditprepare: function() {
        $('#node-input-len').typedInput({
          default: $('#node-input-lenType').val(),
          types: ['num','msg', 'flow', 'global'],
          typeField: $('#node-input-lenType')
        });
      }
  });

  RED.nodes.registerType('play',{
      category: 'jambonz',
      color: '#bbabaa',
      defaults: {
        name: {value: ''},
        url: {required: true},
        urlType: {value: 'str'},
        early: {value: false},
        loop: {value: 1, required: true,  validate: RED.validators.number()},
      },
      inputs:1,
      outputs:1,
      icon: "font-awesome/fa-cubes",
      label: function() { return this.name || 'play';},
      oneditprepare: function() {
        $('#node-input-url').typedInput({
          default: $('#node-input-urlType').val(),
          types: ['str','msg', 'flow', 'global'],
          typeField: $('#node-input-urlType')
        });
      }
  });

  RED.nodes.registerType('redirect', {
    category: 'jambonz',
    color: '#bbabaa',
    defaults: {
      name: {value: ''},
      hook: {required: true},
      hookType: {value: 'str'}
    },
    inputs:1,
    outputs:1,
    icon: "font-awesome/fa-cubes",
    label: function() { 
      return this.name || 'redirect';
    },
    oneditprepare: function() {
      $('#node-input-hook').typedInput({
        types: ['str', 'msg', 'flow', 'global', 'jsonata', 'env'],
        typeField: $('#node-input-hookType')
      });
      }
  });

  RED.nodes.registerType('say',{
      category: 'jambonz',
      color: '#bbabaa',
      defaults: {
        name: {value: ''},
        text: {required: true},
        early: {value: false},
        loop: {value: 1},
        vendor: {value: 'default'},
        lang: {value: 'default'},
        xlang: {},
        voice: {value: 'default'},
        xvoice: {}
      },
      inputs:1,
      outputs:1,
      icon: "font-awesome/fa-cubes",
      label: function() { return this.name || 'say';},
      oneditprepare: () => {
        var node = this;
        prepareTtsControls(node);
      }
  });

  RED.nodes.registerType('sip:decline',{
      category: 'jambonz',
      color: '#bbabaa',
      defaults: {
        name: {value: ''},
        status: {},
        statusType: {value: 'num'},
        reason: {value: ''},
        reasonType: {value: 'str'}
      },
      inputs:1,
      outputs:1,
      icon: "font-awesome/fa-cubes",
      label: function() { return this.name || 'sip:decline';},
      oneditprepare: function() {
        $('#node-input-status').typedInput({
          default: $('#node-input-statusType').val(),
          types: ['num','msg', 'flow', 'global'],
          typeField: $('#node-input-statusType')
        });
        $('#node-input-reason').typedInput({
          default: $('#node-input-reasonType').val(),
          types: ['str','msg', 'flow', 'global'],
          typeField: $('#node-input-reasonType')
        });
      }
  });

  RED.nodes.registerType('tag',{
    category: 'jambonz',
    color: '#bbabaa',
    defaults: {
      name: {value: ''},
      data: {required: true},
      dataType: {value: 'json'}
    },
    inputs:1,
    outputs:1,
    icon: "font-awesome/fa-cubes",
    label: function() { return this.name || 'tag';},
    oneditprepare: function() {
      $('#node-input-data').typedInput({
        default: $('#node-input-dataType').val(),
        types: ['json', 'msg', 'flow', 'global'],
        typeField: $('#node-input-dataType')
      });
    }
  });

  RED.nodes.registerType('jambonz_auth',{
    category: 'config',
    credentials: {
      url: {type: 'text'},
      accountSid: {type: 'text'},
      apiToken: {type: 'text'}
    },
    label: function() { 
      return this.credentials ? this.credentials.url : null;
    },
    oneditprepare: function() {
      $('#btn-test-credentials').on('click', testCredentials);
    }
  });

  RED.nodes.registerType('aws_auth',{
    category: 'config',
    credentials: {
      accessKey: {type: 'text'},
      secretAccessKey: {type: 'text'}
    },
    label: function() { 
      if (!this.credentials) return null;
      const akey = this.credentials.accessKey;
      let mask = '';
      for (let i = 4; i < akey.length; i++) mask += '*';
      return akey.substr(0, 4) + mask;
    }
  });

  RED.nodes.registerType('lcc',{
      category: 'jambonz',
      color: '#aebfb9',
      defaults: {
        name: {value: ''},
        server: {value: '', required: true, type: 'jambonz_auth'},
        callSid: {required: true},
        callSidType: {value: 'msg'},
        action: {value: 'hangup', required: true},
        text: {value: '', validate: function(v) {
          const action = $('#node-input-action').val();
          return action !== 'whisper' || v.length > 0;
        }},
        vendor: {value: 'default'},
        lang: {value: 'default'},
        voice: {value: 'default'},
        callHook: {value: '', validate: function(v) {
          const action = $('#node-input-action').val();
          return action !== 'redirect' || v.length > 0;
        }},
        callHookType: {value: 'str'},
        waitHook: {value: '', validate: function(v) {
          const action = $('#node-input-action').val();
          return action !== 'hold_conf' || v.length > 0;
        }},
        waitHookType: {value: 'str'},
      },
      inputs:1,
      outputs:1,
      icon: "font-awesome/fa-cubes",
      label: function() { 
        return this.name || (this.action ? `LCC - ${this.action}` : 'LCC');
      },
      oneditprepare: function() {
        var node = this;
        var actionElem = $('#node-input-action');
        var vendorElem = $('#node-input-vendor');
        var langElem = $('#node-input-lang');
        var voiceElem = $('#node-input-voice');
        var sayDiv = $('#say-options');
        var redirectDiv = $('#redirect-options');
        var waitHookDiv = $('#wait-options');
        sayDiv.hide();
        waitHookDiv.hide();

        $('#node-input-callSid').typedInput({
          default: $('#node-input-callSidType').val(),
          types: ['str','msg', 'flow', 'global'],
          typeField: $('#node-input-callSidType')
        });
        $('#node-input-callHook').typedInput({
          default: $('#node-input-callHookType').val(),
          types: ['str','msg', 'flow', 'global'],
          typeField: $('#node-input-callHookType')
        });
        $('#node-input-waitHook').typedInput({
          default: $('#node-input-waitHookType').val(),
          types: ['str','msg', 'flow', 'global'],
          typeField: $('#node-input-waitHookType')
        });

        var onActionChanged = function () {
          node.action = actionElem.find(':selected').val();
          if ('whisper' === node.action) sayDiv.show();
          else sayDiv.hide();
          if ('redirect' === node.action) redirectDiv.show();
          else redirectDiv.hide();
          if ('hold_conf' === node.action) waitHookDiv.show();
          else waitHookDiv.hide();
        }

        var onVendorChanged = function() {
          node.vendor = vendorElem.find(':selected').val();
          console.log(`say vendor changed to ${node.vendor}`);
          setLanguage(node.vendor);
        }

        var onLangChanged = function() {
          node.lang = langElem.find(':selected').val();
          console.log(`language changed to ${node.lang}`);
          setVoice(node.vendor, node.lang)
        }
      
        var onVoiceChanged = function() {
          node.voice = voiceElem.find(':selected').val();
          console.log(`voice changed to ${node.voice}`);
        }

        var setLanguage = function(v) {
          langElem.find('option').remove();
          voiceElem.find('option').remove();

          switch (v) {
            case 'default': 
              langElem.append('<option value="default" selected>--application default--</option>');
              voiceElem.append('<option value="default" selected>--application default--</option>');
              node.lang = 'default';
              node.voice = 'default';
              break;

            case 'google':
              langElem.append(googleLanguageOptions);
              break;

            case 'aws':
              langElem.append(awsLanguageOptions);
              break;
          }
          langElem.val(node.lang);
        }

        var setVoice = function(vendor, lang) {
          console.log(`say set voice for language ${lang} vendor ${vendor}`);
          voiceElem.find('option').remove();

          switch (vendor) {
            case 'default':
              voiceElem.append('<option value="default" selected>--application default--</option>');
              break;

            case 'google':
            case 'aws':
              var obj = 'google' === vendor ? mapGoogle[lang] : mapAws[lang];
              if (obj) {
                var options = '';
                for (var i = 0; i < obj.voices.length; i++) {
                  if (i) options += `<option value="${obj.voices[i].value}">${obj.voices[i].name}</option>`;
                  else options += `<option value="${obj.voices[i].value}">${obj.voices[i].name}</option>`;
                }
                voiceElem.append(options);
              }
              break;
          }
          voiceElem.val(node.voice);
        }

        actionElem.change(onActionChanged);
        vendorElem.change(onVendorChanged);
        langElem.change(onLangChanged);
        voiceElem.change(onVoiceChanged);
      }
  });

  RED.nodes.registerType('create-call',{
      category: 'jambonz',
      color: '#aebfb9',
      defaults: {
        name: {value: ''},
        server: {value: '', required: true, type: 'jambonz_auth'},
        from: {value: '', required: true},
        fromType: {value: ''},
        to: {value: '', required: true},
        toType: {value: ''},
        dest: {value: 'phone', required: true},
        timeout: {},
        application: {value: '', required: true},
        appName: {}
      },
      inputs:1,
      outputs:1,
      icon: "font-awesome/fa-cubes",
      label: function() { 
        return this.name || 'create call';
      },
      oneditprepare: function() {
        var node = this;
        var destElem = $('#node-input-dest');
        var serverElem = $('#node-input-server');
        var applicationElem = $('#node-input-application');

        $('#node-input-from').typedInput({
          default: $('#node-input-fromType').val(),
          types: ['str','msg', 'flow', 'global'],
          typeField: $('#node-input-fromType')
        });
        $('#node-input-to').typedInput({
          default: $('#node-input-toType').val(),
          types: ['str','msg', 'flow', 'global'],
          typeField: $('#node-input-toType')
        });


        var populateApplications = function() {
          var serverId = $('#node-input-server option:selected').val();
          var conn = RED.nodes.node(serverId);
          console.log(`server id ${serverId} has conn`, conn);
          if (conn && conn.credentials) {
            const {url, accountSid, apiToken} = conn.credentials;

            $.ajax({
              url: `${url}/v1/Applications`,
              headers: {
                'Authorization': `Bearer ${apiToken}`
              },
              dataType: 'json',
              timeout: 500,
              error: (err) => {
                console.log(err);
              },
              success: (res) => {
                console.log(`response from fetch of applications: ${JSON.stringify(res)}`);
                console.log(`selected app is ${JSON.stringify(node.application)}`);
                applicationElem.find('option').remove();
                var options = '';
                res.forEach((app) => {
                  if (node.application === app.application_sid) {
                    options += `<option value="${app.application_sid}" selected>${app.name}</option>`;
                    node.appName = app.name;
                  }
                  else {
                    options += `<option value="${app.application_sid}">${app.name}</option>`;
                  }
                });
                if (options.length) applicationElem.append(options);
              }
            });
          }
          else {
            console.log(`can't retrieve config, but application_sid is '${node.appName}': ${node.application}`);
            applicationElem.find('option').remove();
            applicationElem.append(`<option value="${node.application}">${node.appName}</option>`);
          }
        }
        serverElem.change(populateApplications);
        applicationElem.change(() => {
          node.appName = $('#node-input-application option:selected').text();
          console.log(`setting appName to ${node.appName}`);
        });
      }
  });

  RED.nodes.registerType('create-sms',{
      category: 'jambonz',
      color: '#aebfb9',
      defaults: {
        name: {value: ''},
        server: {value: '', required: true, type: 'jambonz_auth'},
        from: {value: '', required: true},
        fromType: {value: ''},
        to: {value: '', required: true},
        toType: {value: ''},
        text: {value: '', required: true},
        textType: {value: ''},
        provider: {value: ''},
        providerType: {value: ''},
      },
      inputs:1,
      outputs:1,
      icon: "font-awesome/fa-cubes",
      label: function() { 
        return this.name || 'create sms';
      },
      oneditprepare: function() {
        var node = this;

        $('#node-input-from').typedInput({
          default: $('#node-input-fromType').val(),
          types: ['str','msg', 'flow', 'global'],
          typeField: $('#node-input-fromType')
        });
        $('#node-input-to').typedInput({
          default: $('#node-input-toType').val(),
          types: ['str','msg', 'flow', 'global'],
          typeField: $('#node-input-toType')
        });
        $('#node-input-text').typedInput({
          default: $('#node-input-textType').val(),
          types: ['str','msg', 'flow', 'global'],
          typeField: $('#node-input-textType')
        });
        $('#node-input-provider').typedInput({
          default: $('#node-input-providerType').val(),
          types: ['str','msg', 'flow', 'global'],
          typeField: $('#node-input-providerType')
        });
      }
  });

</script>


<!-- user auth -->
<script type="text/html" data-template-name="user auth">
  <div class="form-row">
    <label for="node-input-name"><i class="icon-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name">
  </div>
  <fieldset>
    <legend>Enter either a plain-text or hashed password</legend>
    <div class="form-row">
      <label for="node-input-password">Plain text password</label>
      <input type="text" id="node-input-password">
      <input type="hidden" id="node-input-passwordType">
    </div>
    <div class="form-row">
      <label for="node-input-ha1">Hashed</label>
      <input type="text" id="node-input-ha1">
      <input type="hidden" id="node-input-ha1Type">
    </div>
  </fieldset>
</script>

<script type="text/html" data-help-name="user auth">
  <p>Authenticate a user</p>
  <h3>Inputs</h3>
  <dl class="message-properties">
      <dt>authRequest<span class="property-type">object</span></dt>
      <dd>The digest parameters provided by the user</dd>
  </dl>

<h3>Outputs</h3>
<dl class="message-properties">
   <dt>authResponse<span class="property-type">object</span></dt>
   <dd>An object containing a status property indicating whether the password provided has successfully authenticated the user</dd>
</dl>

<h3>Details</h3>
The user auth command is used to authenticate a user based on the sip digest they presented and a password retrieved by some means by the application.
You may provide either a plaintext password, or a precomputed hash based on <a href="https://tools.ietf.org/html/rfc2617">RFC 2617</a>, i.e. MD5( username ":" realm ":" password ).<br/><br/>
It is valid to provide neither the plaintext nor hashed password, and in this case the user authentication will fail.  
It is useful to do this, for instance, when either the presented domain or username are unrecognized.<br/><br/>
The output of this node is to set <code>msg.authResponse</code> accordingly, and the <code>webhook out</code> node should then be used to send the result back to the jambonz server.
<h3>References</h3>
  <ul>
      <li><a href="https://docs.jambonz.org/register-hook">Jambonz user authentication reference</a></li>
  </ul>
</script>

<!-- conference -->
<script type="text/html" data-template-name="conference">
  <div class="form-row">
    <label for="node-input-name"><i class="icon-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name">
  </div>
  <div class="form-row">
    <label for="node-input-conference">Conference name</label>
    <input type="text" id="node-input-conference" placeholder="conference to join">
    <input type="hidden" id="node-input-conferenceType">
  </div>
  <div class="form-row">
    <label for="node-input-enterHook">Enter hook</label>
    <input type="text" id="node-input-enterHook" placeholder="webhook url">
    <input type="hidden" id="node-input-enterHookType">
  </div>
  <div class="form-row">
    <label for="node-input-waitHook">Wait hook</label>
    <input type="text" id="node-input-waitHook" placeholder="webhook url">
    <input type="hidden" id="node-input-waitHookType">
  </div>
  <div class="form-row">
    <label for="node-input-beep">Beep on entry</label>
    <input type="checkbox" id="node-input-beep">
  </div>
  <div class="form-row">
    <label for="node-input-startConferenceOnEnter">Start on entry</label>
    <input type="checkbox" id="node-input-startConferenceOnEnter">
  </div>
  <div class="form-row">
    <label for="node-input-endConferenceOnExit">End on exit</label>
    <input type="checkbox" id="node-input-endConferenceOnExit">
  </div>
  <div class="form-row">
    <label for="node-input-joinMuted">Join Muted</label>
    <input type="checkbox" id="node-input-joinMuted">
  </div>
  <div class="form-row">
    <label for="node-input-maxParticipants">Max participants</label>
    <input type="text" id="node-input-maxParticipants">
    <input type="hidden" id="node-input-maxParticipantsType">
  </div>
</script>

<script type="text/html" data-help-name="conference">
  <p>places a caller in a queue.</p>
  <h3>Inputs</h3>
  <dl class="message-properties">
    <dt>Conference Name<span class="property-type">string</span></dt>
    <dd>The name of the conference to join the caller to.</dd>
    <dt>Enter hook<span class="property-type">string</span></dt>
    <dd>A webhook to retrieve something to play or say to the caller just before they are put into a conference after waiting for it to start</dd>
    <dt>Wait hook<span class="property-type">string</span></dt>
    <dd>A webhook to retrieve commands to play or say while the caller is waiting for the conference to start</dd>
    <dt>Beep on entry<span class="property-type">boolean</span></dt>
    <dd>if checked, play a beep tone to the conference when caller enters </dd>
    <dt>Start on entry<span class="property-type">boolean</span></dt>
    <dd>if checked, start the conference only when this caller enters</dd>
    <dt>End on exit<span class="property-type">boolean</span></dt>
    <dd>if checked, end the conference when this caller hangs up</dd>
    <dt>Max participants<span class="property-type">number</span></dt>
    <dd>maximum number of participants that will be allowed in the conference</dd>
</dl>

<h3>Outputs</h3>
<dl class="message-properties">
   <dt>jambonz<span class="property-type">object</span></dt>
   <dd> <code>msg.jambonz</code> will contain any previous actions provided to the input with the new <code>conference</code> action appended  </dd>
</dl>

<h3>Details</h3>
The conference verb places a call into a conference.
<h3>References</h3>
  <ul>
      <li><a href="https://docs.jambonz.org/jambonz/#conference">Jambonz conference reference</a></li>
  </ul>
</script>

<!-- dequeue -->
<script type="text/html" data-template-name="dequeue">
  <div class="form-row">
    <label for="node-input-name"><i class="icon-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name">
  </div>
  <div class="form-row">
    <label for="node-input-queue">Queue name</label>
    <input type="text" id="node-input-queue" placeholder="name of queue to remove caller from">
    <input type="hidden" id="node-input-queueType">
  </div>
  <div class="form-row">
    <label for="node-input-beep">Play beep on connecting</label>
    <input type="checkbox" id="node-input-beep">
  </div>
  <div class="form-row">
    <label for="node-input-actionHook">Action hook</label>
    <input type="text" id="node-input-actionHook" placeholder="webhook url">
    <input type="hidden" id="node-input-actionHookType">
  </div>
  <div class="form-row">
    <label for="node-input-confirmHook">Confirm hook</label>
    <input type="text" id="node-input-confirmHook" placeholder="webhook url">
    <input type="hidden" id="node-input-confirmHookType">
  </div>
  <div class="form-row">
    <label for="node-input-timeout">Timeout</label>
    <input type="text" id="node-input-timeout" placeholder="seconds to wait if queue is empty">
    <input type="hidden" id="node-input-timeoutType">
  </div>
</script>

<script type="text/html" data-help-name="dequeue">
  <p>removes the a call from the front of a queue and bridges that call to the current caller.</p>
  <h3>Inputs</h3>
  <dl class="message-properties">
    <dt>Queue name<span class="property-type">string</span></dt>
    <dd>Name of the queue.</dd>
    <dt>Play beep on connecting<span class="property-type">boolean</span></dt>
    <dd>Play a beep tone to this caller only just prior to connecting the queued call.</dd>
    <dt>Action hook<span class="property-type">string</span></dt>
    <dd>A webhook invoke when call ends.</dd>
    <dt>Confirm hook<span class="property-type">string</span></dt>
    <dd>A webhook for an application to run on the callee's end before the call is bridged.</dd>
    <dt>Timeout<span class="property-type">number</span></dt>
    <dd>number of seconds to wait on an empty queue before returning.</dd>
</dl>

<h3>Outputs</h3>
<dl class="message-properties">
   <dt>jambonz<span class="property-type">object</span></dt>
   <dd> <code>msg.jambonz</code> will contain any previous actions provided to the input with the new <code>dequeue</code> action appended  </dd>
</dl>

<h3>Details</h3>
The dequeue verb removes the a call from the front of a specified queue and bridges that call to the current caller.
<h3>References</h3>
  <ul>
      <li><a href="https://docs.jambonz.org/jambonz/#dequeue">Jambonz dequeue reference</a></li>
  </ul>
</script>

<!-- dial -->
<script type="text/html" data-template-name="dial">
  <style>
    ol#node-input-target-container .red-ui-typedInput-container {
      flex:1;
    }
  </style>
  <div class="form-row">
    <label for="node-input-name"><i class="icon-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name">
  </div>
  <div class="form-row" style="margin-bottom:0;">
    <label><i class="fa fa-list"></i><span>Dial Targets</span></label>
  </div>
  <div class="form-row node-input-target-container-row">
      <ol id="node-input-target-container"></ol>
  </div>
  <div class="form-row">
    <label for="node-input-actionhook">Action hook</label>
    <input type="text" id="node-input-actionhook" placeholder="webhook to invoke when the call ends">
    <input type="hidden" id="node-input-actionhookType">
  </div>
  <div class="form-row">
    <label for="node-input-answeronbridge">Answer on bridge</label>
    <input type="checkbox" id="node-input-answeronbridge">
  </div>
  <div class="form-row">
    <label for="node-input-callerid">Caller ID</label>
    <input type="text" id="node-input-callerid" placeholder="Caller ID to place on outbound call">
    <input type="hidden" id="node-input-calleridType">
  </div>
  <div class="form-row">
    <label for="node-input-confirmhook">Confirm hook</label>
    <input type="text" id="node-input-confirmhook" placeholder="webhook to run on called party after answer">
    <input type="hidden" id="node-input-confirmhookType">
  </div>
  <div class="form-row">
    <label for="node-input-dialmusic">Dial music</label>
    <input type="text" id="node-input-dialmusic" placeholder="url to .wav or .mp3 file to play during dial">
    <input type="hidden" id="node-input-dialMusicType">
  </div>
  <div class="form-row">
    <label for="node-input-dtmfcapture">Dtmf capture</label>
    <input type="text" id="node-input-dtmfcapture" placeholder="comma-separated list of dtmf captures">
    <input type="hidden" id="node-input-dtmfcaptureType">
  </div>
  <div class="form-row">
    <label for="node-input-dtmfhook">Dtmf hook</label>
    <input type="text" id="node-input-dtmfhook" placeholder="webhook to call when dtmf is captured">
    <input type="hidden" id="node-input-dtmfhookType">
  </div>
  <div class="form-row">
    <label for="node-input-timelimit">Time limit</label>
    <input type="text" id="node-input-timelimit" placeholder="max duration of call in secs">
  </div>
  <div class="form-row">
    <label for="node-input-timeout"><i class="icon-tag"></i> Timeout</label>
    <input type="text" id="node-input-timeout" placeholder="ring no answer timeout in secs (default: 60)">
  </div>
  <fieldset>
    <legend>Live audio</legend>
    <div class="form-row">
      <label for="node-input-listenurl"><i class="icon-tag"></i> Websocket server url</label>
      <input type="text" id="node-input-listenurl" placeholder="ws://example.com">
      <input type="hidden" id="node-input-listenurlType">
    </div>
  </fieldset>
  <fieldset>
    <legend>Transcription (optional)</legend>
    <div class="form-row">
      <label for="node-input-transcriptionhook"><i class="icon-tag"></i> Transcription hook</label>
      <input type="text" id="node-input-transcriptionhook" placeholder="transcription webhook">
      <input type="hidden" id="node-input-transcriptionhookType">
    </div>
    <div class="form-row">
      <label for="node-input-transcriptionvendor">Vendor</label>
      <select id="node-input-transcriptionvendor">
        <option value="default" selected>--application default--</option>
        <option value="google">Google</option>
        <option value="aws">AWS</option>
      </select>
    </div>
    <div class="form-row">
      <label for="node-input-recognizerlang"><i class="icon-tag"></i> Language</label>
      <select id="node-input-recognizerlang">
      </select>
    </div>
    <div id="interim" class="form-row">
      <label for="node-input-interim">Interim transcriptions</label>
      <input type="checkbox" id="node-input-interim">
    </div>
    <div id="stt-identify-channels" class="form-row">
      <label for="node-input-separaterecog">Separate recognition per channel</label>
      <input type="checkbox" id="node-input-separaterecog">
    </div>
    <div id="google-stt-options">
      <legend>Google Transcription Options</legend>
      <div class="form-row">
        <label for="node-input-transcriptionhints">Hints</label>
        <input type="text" id="node-input-transcriptionhints" placeholder="comma-separated list of phrases">
        <input type="hidden" id="node-input-transcriptionhintsType">
      </div>
      <div class="form-row">
        <label for="node-input-recognizeraltlang">Alternative languages</label>
        <input type="text" id="node-input-recognizeraltlang" placeholder="comma-separated list of add'l lang codes">
        <input type="hidden" id="node-input-recognizeraltlangType">
      </div>
      <div class="form-row">
        <label for="node-input-useenhanced">Use enhanced model</label>
        <input type="checkbox" id="node-input-useenhanced">
      </div>
      <div class="form-row">
        <label for="node-input-profanityfilter">Profanity filter</label>
        <input type="checkbox" id="node-input-profanityfilter">
      </div>
      <div class="form-row">
        <label for="node-input-words">Word time offsets</label>
        <input type="checkbox" id="node-input-words">
      </div>
      <div class="form-row">
        <label for="node-input-punctuation">Automatic punctuation</label>
        <input type="checkbox" id="node-input-punctuation">
      </div>
      <div class="form-row">
        <label for="node-input-diarization">Speaker diarization</label>
        <input type="checkbox" id="node-input-diarization">
      </div>
      <div class="form-row">
        <label for="node-input-diarizationmin">Min speaker count</label>
        <input type="text" id="node-input-diarizationmin" placeholder="2">
        <input type="hidden" id="node-input-diarizationminType">
      </div>
      <div class="form-row">
        <label for="node-input-diarizationmax">Max speaker count</label>
        <input type="text" id="node-input-diarizationmax" placeholder="6">
        <input type="hidden" id="node-input-diarizationmaxType">
      </div>    
      <div class="form-row">
        <label for="node-input-interactiontype">Type of Interaction</label>
        <select id="node-input-interactiontype">
          <option value="unspecified" selected>Unspecified</option>
          <option value="discussion">Discusssion</option>
          <option value="presentation">Presentation</option>
          <option value="phone_call">Phone call</option>
          <option value="voicemail">Voicemail</option>
          <option value="voice_search">Voice search</option>
          <option value="voice_command">Voice command</option>
          <option value="dictation">Dictation</option>
        </select>
      </div>
      <div class="form-row">
        <label for="node-input-naics">Industry NAICS code</label>
        <input type="text" id="node-input-naics">
        <input type="hidden" id="node-input-naicsType">
      </div>
    </div>
    <div id="aws-stt-options">
      <legend>AWS Transcription Options</legend>
      <div class="form-row">
        <label for="node-input-identifychannels">Enable channel identification</label>
        <input type="checkbox" id="node-input-identifychannels">
      </div>
      <div class="form-row">
        <label for="node-input-speakerlabel">Show speaker labels</label>
        <input type="checkbox" id="node-input-speakerlabel">
      </div>
      <div class="form-row">
        <label for="node-input-vocabularyname">Vocabulary name</label>
        <input type="text" id="node-input-vocabularyname">
        <input type="hidden" id="node-input-vocabularynameType">
      </div>
      <div class="form-row">
        <label for="node-input-vocabularyfiltername">Vocabulary filter name</label>
        <input type="text" id="node-input-vocabularyfiltername">
        <input type="hidden" id="node-input-vocabularyfilternameType">
      </div>
      <div class="form-row">
        <label for="node-input-vocabularyfiltermethod">Filter method</label>
        <select id="node-input-vocabularyfiltermethod">
          <option value="remove" selected>Remove</option>
          <option value="mask" selected>Mask</option>
          <option value="tag" selected>Tag</option>
        </select>
      </div>
    </div>
  </fieldset>
  <fieldset>
    <legend>SIP Headers</legend>
    <div class="form-row" style="margin-bottom:0;">
      <label style="width:100%"><i class="fa fa-list"></i> <span>Add custom headers on outdial</span></label>
    </div>
    <div class="form-row node-input-headers-container-row">
        <ol id="node-input-headers-container"></ol>
    </div>
  </fieldset>
</div>
</script>

<script type="text/html" data-help-name="dial">
  <p>Dial out to a phone number, registered user, sip endpoint, or Microsoft teams user</p>
  <h3>Inputs</h3>
  <dl class="message-properties">
    <dt>Dial target - phone<span class="property-type">string</span></dt>
    <dd>A telephone number to dial in E.164 format</dd>
    <dt>Dial target - user<span class="property-type">string</span></dt>
    <dd>A registered sip user in user@domain format</dd>
    <dt>Dial target - sip<span class="property-type">string</span></dt>
    <dd>A sip endpoint in sip uri format, optionally with sip username and password</dd>
    <dt>Dial target - teams<span class="property-type">string</span></dt>
    <dd>A phone number that is associated with a user in the Microsoft Teams tenant associated with this account</dd>
    <dt>Action hook<span class="property-type">string</span></dt>
    <dd>webhook to invoke when the call ends.	</dd>
    <dt>Answer on bridge<span class="property-type">string</span></dt>
    <dd>If set to true, the inbound call will ring until the number that was dialed answers the call, and at that point a 200 OK will be sent on the inbound leg. If false, the inbound call will be answered immediately as the outbound call is placed.</dd>
    <dt>Action hook<span class="property-type">string</span></dt>
    <dd>webhook to invoke when the call ends.	</dd>
    <dt>Caller ID<span class="property-type">string</span></dt>
    <dd>Calling phone number to display on outgoing call.</dd>
    <dt>Confirm hook<span class="property-type">string</span></dt>
    <dd>webhook for an application to run on the callee's end after the dialed number answers but before the call is connected.</dd>
    <dt>Dial music<span class="property-type">string</span></dt>
    <dd>url that specifies a .wav or .mp3 audio file of custom audio or ringback to play to the caller while the outbound call is ringing.</dd>
    <dt>Dtmf capture<span class="property-type">string</span></dt>
    <dd>an array of strings that represent dtmf sequence which, when detected, will trigger a mid-call notification to the application via the configured dtmfHook.</dd>
    <dt>DTMF hook<span class="property-type">string</span></dt>
    <dd>webhook to call when a dtmfCapture entry is matched.</dd>
    <dt>Time limit<span class="property-type">number</span></dt>
    <dd>max length of call in seconds.</dd>
    <dt>Time limit<span class="property-type">number</span></dt>
    <dd>max length of call in seconds.</dd>
    <dt>Timeout<span class="property-type">number</span></dt>
    <dd>ring no answer timeout in seconds.</dd>
    <dt>Websocket server url<span class="property-type">string</span></dt>
    <dd>url of remote websocket server to send live audio to.</dd>
    <dt>Transcription hook<span class="property-type">string</span></dt>
    <dd>webhook to call when a transcription is received.</dd>
    <dt>Language<span class="property-type">string</span></dt>
    <dd>language to use for speech transcription.</dd>
    <dt>Send interim transcriptions<span class="property-type">boolean</span></dt>
    <dd>if true interim transcriptions are sent.</dd>
</dl>

  <h3>Outputs</h3>
  <dl class="message-properties">
    <dt>jambonz<span class="property-type">object</span></dt>
    <dd> <code>msg.jambonz</code> will contain any previous actions provided to the input with the new <code>dial</code> action appended  </dd>
  </dl>

  <h3>Details</h3>
  The dial verb is used to create a new call by dialing out to a number, a registered sip user, or sip endpoint
    <ul>
        <li><a href="https://docs.jambonz.org/jambonz/#dial">Jambonz dial reference</a></li>
    </ul>
</script>

<!-- enqueue -->
<script type="text/html" data-template-name="enqueue">
  <div class="form-row">
    <label for="node-input-name"><i class="icon-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name">
  </div>
  <div class="form-row">
    <label for="node-input-queue">Queue name</label>
    <input type="text" id="node-input-queue" placeholder="name of queue">
    <input type="hidden" id="node-input-queueType">
  </div>
  <div class="form-row">
    <label for="node-input-actionHook">Action hook</label>
    <input type="text" id="node-input-actionHook" placeholder="webhook url">
    <input type="hidden" id="node-input-actionHookType">
  </div>
  <div class="form-row">
    <label for="node-input-waitHook">Wait hook</label>
    <input type="text" id="node-input-waitHook" placeholder="webhook url">
    <input type="hidden" id="node-input-waitHookType">
  </div>
</script>

<script type="text/html" data-help-name="enqueue">
  <p>places a caller in a queue.</p>
  <h3>Inputs</h3>
  <dl class="message-properties">
    <dt>Queue name<span class="property-type">string</span></dt>
    <dd>The name of the queue</dd>
    <dt>Action hook<span class="property-type">string</span></dt>
    <dd>A webhook invoke when operation completes.</dd>
    <dt>Wait hook<span class="property-type">string</span></dt>
    <dd>A webhook to invoke while the caller is in queue. The only allowed verbs in the application returned from this webhook are say, play, pause, and leave,.</dd>
</dl>

<h3>Outputs</h3>
<dl class="message-properties">
   <dt>jambonz<span class="property-type">object</span></dt>
   <dd> <code>msg.jambonz</code> will contain any previous actions provided to the input with the new <code>enqueue</code> action appended  </dd>
</dl>

<h3>Details</h3>
The enqueue command is used to place a caller in a queue.
<h3>References</h3>
  <ul>
      <li><a href="https://docs.jambonz.org/jambonz/#enqueue">Jambonz enqueue reference</a></li>
  </ul>
</script>

<!-- gather -->
<script type="text/html" data-template-name="gather">
  <div class="form-row">
    <label for="node-input-name"><i class="icon-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name">
</div>
<div class="form-row">
  <label for="node-input-actionhook"><i class="icon-tag"></i> Action hook</label>
  <input type="text" id="node-input-actionhook" placeholder="webhook with results of gather">
</div>
<fieldset>
  <legend>Prompt</legend>
  <div class="form-row">
    <label for="node-input-prompttype"><i class="icon-tag"></i> Verb</label>
    <select id="node-input-prompttype">
      <option>play</option>
      <option selected>say</option>
    </select>
  </div>

  <div id="say-container">
    <div class="form-row">
      <label for="node-input-text"><i class="icon-tag"></i> Text</label>
      <textarea id="node-input-text" rows="4" placeholder="Text or SSML to speak" style="width:70%"></textarea>
    </div>
    <div class="form-row">
      <label for="node-input-vendor"> Vendor</label>
      <select id="node-input-vendor">
        <option value="default" selected>--application default--</option>
        <option value="google">google</option>
        <option value="aws">aws/polly</option>
      </select>
    </div>
    <div class="form-row" style="display: none;">
      <label for="node-input-lang"> Lang</label>
      <input type="text" id="node-input-lang">
    </div>
    <div class="form-row">
      <label for="node-input-xlang">Language</label>
      <select id="node-input-xlang">
        <option value="default" selected>--application default--</option>
      </select>
    </div>
    <div class="form-row" style="display: none;">
      <label for="node-input-voice"> Voice</label>
      <input type="text" id="node-input-voice">
    </div>
    <div class="form-row">
      <label for="node-input-xvoice">Voice</label>
      <select id="node-input-xvoice">
        <option value="default" selected>--application default--</option>
      </select>
    </div>
  </div>

  <div id="play-container">
    <div class="form-row">
      <label for="node-input-playurl"> Url</label>
      <input type="text" id="node-input-playurl" placeholder="url of file to play">
      <input type="hidden" id="node-input-playurlType">
    </div>
  </div>
</fieldset>
<fieldset>
  <legend>DTMF Input</legend>
  <div class="form-row">
    <label for="node-input-dtmfinput">Accept DTMF input</label>
    <input type="checkbox" id="node-input-dtmfinput">
  </div>
  <div id="dtmf-input-container">
    <div class="form-row">
      <label for="node-input-finishonkey"><i class="icon-tag"></i> Finish key</label>
      <input type="text" id="node-input-finishonkey" placeholder="dtmf key to signal end of input">
    </div>
    <div class="form-row">
      <label for="node-input-numdigits"><i class="icon-tag"></i> Num. digits</label>
      <input type="text" id="node-input-numdigits" placeholder="number of digits to collect">
    </div>
    <div class="form-row">
      <label for="node-input-numtimeout"><i class="icon-tag"></i> Timeout</label>
      <input type="text" id="node-input-timeout" placeholder="dtmf timeout in secs">
    </div>
  </div>
</fieldset>
<fieldset>
  <legend>Speech Input</legend>
  <div class="form-row">
    <label for="node-input-speechinput">Accept Speech input</label>
    <input type="checkbox" id="node-input-speechinput">
  </div>
  <div id="speech-input-container">
    <div class="form-row">
      <label for="node-input-transcriptionvendor">Vendor</label>
      <select id="node-input-transcriptionvendor">
        <option value="default" selected>--application default--</option>
        <option value="google">Google</option>
        <option value="aws">AWS</option>
      </select>
    </div>
    <div class="form-row">
      <label for="node-input-recognizerlang"><i class="icon-tag"></i> Language</label>
      <select id="node-input-recognizerlang">
      </select>
    </div>
    <div id="google-stt-options">
      <legend>Google Transcription Options</legend>
      <div class="form-row">
        <label for="node-input-transcriptionhints">Hints</label>
        <input type="text" id="node-input-transcriptionhints" placeholder="comma-separated list of phrases">
        <input type="hidden" id="node-input-transcriptionhintsType">
      </div>
      <div class="form-row">
        <label for="node-input-recognizeraltlang">Alternative languages</label>
        <input type="text" id="node-input-recognizeraltlang" placeholder="comma-separated list of add'l lang codes">
        <input type="hidden" id="node-input-recognizeraltlangType">
      </div>
      <div class="form-row">
        <label for="node-input-naics">Industry NAICS code</label>
        <input type="text" id="node-input-naics">
        <input type="hidden" id="node-input-naicsType">
      </div>
    </div>
    <div id="aws-stt-options">
      <legend>AWS Transcription Options</legend>
      <div class="form-row">
        <label for="node-input-vocabularyname">Vocabulary name</label>
        <input type="text" id="node-input-vocabularyname">
        <input type="hidden" id="node-input-vocabularynameType">
      </div>
      <div class="form-row">
        <label for="node-input-vocabularyfiltername">Vocabulary filter name</label>
        <input type="text" id="node-input-vocabularyfiltername">
        <input type="hidden" id="node-input-vocabularyfilternameType">
      </div>
      <div class="form-row">
        <label for="node-input-vocabularyfiltermethod">Filter method</label>
        <select id="node-input-vocabularyfiltermethod">
          <option value="remove" selected>Remove</option>
          <option value="mask" selected>Mask</option>
          <option value="tag" selected>Tag</option>
        </select>
      </div>
    </div>
  </div>
</fieldset>
</script>

<script type="text/html" data-help-name="gather">
  <p>Collect speech or dtmf input from the caller</p>
  <h3>Inputs</h3>
  <dl class="message-properties">
    <dt>Action hook<span class="property-type">string</span></dt>
    <dd>A webhook invoke when operation completes.</dd>
    <dt>Speech<span class="property-type">boolean</span></dt>
    <dd>Enable speech input.</dd>
    <dt>Digits<span class="property-type">boolean</span></dt>
    <dd>Enable DTMF input.</dd>
    <dt>Language<span class="property-type">string</span></dt>
    <dd>Language to use for speech recognition</dd>
    <dt>Hints<span class="property-type">string</span></dt>
    <dd>Comma-separate list of words or phrases to assist speech detection</dd>
    <dt>Verb<span class="property-type">string</span></dt>
    <dd>Whether to use the play or say verb to prompt the caller</dd>
    <dt>Url<span class="property-type">string</span></dt>
    <dd>Url of prompt to play</dd>
    <dt>Text<span class="property-type">string</span></dt>
    <dd>Text to speak as a prompt to caller</dd>
    <dt>Vendor<span class="property-type">string</span></dt>
    <dd>TTS vendor</dd>
    <dt>Language<span class="property-type">string</span></dt>
    <dd>TTS language</dd>
    <dt>Voice<span class="property-type">string</span></dt>
    <dd>TTS voice</dd>
  </dl>

  <h3>Outputs</h3>
  <dl class="message-properties">
    <dt>jambonz<span class="property-type">object</span></dt>
    <dd> <code>msg.jambonz</code> will contain any previous actions provided to the input with the new <code>gather</code> action appended  </dd>
  </dl>

  <h3>Details</h3>
  The gather command is used to collect dtmf or speech input.
  <h3>References</h3>
    <ul>
        <li><a href="https://docs.jambonz.org/jambonz/#gather">Jambonz gather reference</a></li>
    </ul>
</script>

<!-- hangup -->
<script type="text/html" data-template-name="hangup">
  <div class="form-row">
    <label for="node-input-name"><i class="icon-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name">
</div>
</script>

<script type="text/html" data-help-name="hangup">
  <p>Hangup the call</p>
  <h3>Inputs</h3>
  <dl class="message-properties">
  </dl>

<h3>Outputs</h3>
<dl class="message-properties">
   <dt>jambonz<span class="property-type">object</span></dt>
   <dd> <code>msg.jambonz</code> will contain any previous actions provided to the input with the new <code>hangup</code> action appended  </dd>
</dl>

<h3>Details</h3>
The hangup verb hangs up the current call.
<h3>References</h3>
  <ul>
      <li><a href="https://docs.jambonz.org/jambonz/#hangup">Jambonz hangup reference</a></li>
  </ul>
</script>

<!-- leave -->
<script type="text/html" data-template-name="leave">
  <div class="form-row">
    <label for="node-input-name"><i class="icon-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name">
  </div>
</script>

<script type="text/html" data-help-name="leave">
  <p>transfer call out of queue</p>
  <h3>Inputs</h3>
  <dl class="message-properties">
  </dl>

<h3>Outputs</h3>
<dl class="message-properties">
   <dt>jambonz<span class="property-type">object</span></dt>
   <dd> <code>msg.jambonz</code> will contain any previous actions provided to the input with the new <code>leave</code> action appended  </dd>
</dl>

<h3>Details</h3>
The leave verb transfers a call out of a queue. The call then returns to the flow of execution following the enqueue verb that parked the call, or the document returned by that verbs actionHook property, if provided.<h3>References</h3>
  <ul>
      <li><a href="https://docs.jambonz.org/jambonz/#leave">Jambonz leave reference</a></li>
  </ul>
</script>

<!-- lex -->
<script type="text/html" data-template-name="lex">
  <div class="form-row">
    <label for="node-input-name"><i class="icon-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name">
  </div>
  <div class="form-row">
    <label for="node-input-aws">AWS credentials</label>
    <input type="text" id="node-input-aws">
  </div>  
  <div class="form-row">
    <label for="node-input-bot">Bot ID</label>
    <input type="text" id="node-input-bot" placeholder="bot name">
    <input type="hidden" id="node-input-botType">
  </div>
  <div class="form-row">
    <label for="node-input-alias">Bot Alias</label>
    <input type="text" id="node-input-alias" placeholder="bot alias">
    <input type="hidden" id="node-input-aliasType">
  </div>
  <div class="form-row">
    <label for="node-input-locale">Locale</label>
    <input type="text" id="node-input-locale" placeholder="en_US">
    <input type="hidden" id="node-input-localeType">
  </div>
  <div class="form-row">
    <label for="node-input-region">Region</label>
    <select id="node-input-region">
      <option value="ap-northeast-1">Tokyo (ap-northeast-1)</option>
      <option value="ap-southeast-1">Singapore (ap-southeast-1)</option>
      <option value="ap-southeast-2">Sydney (ap-southeast-2)</option>
      <option value="eu-central-1">Frankfurt (eu-central-1)</option>
      <option value="eu-west-1">Ireland (eu-west-1)</option>
      <option value="eu-west-2">London (eu-west-2)</option>
      <option value="us-east-1" selected>N. Virginia (us-east-1)</option>
      <option value="us-west-2">Oregon (us-west-2)</option>
    </select>
  </div>
  <div class="form-row">
    <label for="node-input-specifyIntent">Initial intent?</label>
    <input type="checkbox" id="node-input-specifyIntent">
  </div>
  <div id="intent-options">
    <div class="form-row">
      <label for="node-input-intent">Intent name</label>
      <input type="text" id="node-input-intent" placeholder="name of initial intent (if any)">
      <input type="hidden" id="node-input-intentType">
    </div>
    <div class="form-row">
      <label for="node-input-slots">Slots</label>
      <input type="text" id="node-input-slots" placeholder="initial slot values (if any)">
      <input type="hidden" id="node-input-slotsType">
    </div>
  </div>
  <div id="welcome-msg-options">
    <div class="form-row">
      <label for="node-input-welcomeMessage">Welcome message</label>
      <textarea id="node-input-welcomeMessage" rows="2" placeholder="Initial message to speak, if any" style="width:65%"></textarea>
    </div>
  </div>
  <div class="form-row">
    <label for="node-input-metadata">Metadata</label>
    <input type="text" id="node-input-metadata" placeholder="key-value pairs to send to lex (if any)">
    <input type="hidden" id="node-input-metadataType">
  </div>
  <div class="form-row">
    <label for="node-input-inputTimeout">Input timeout</label>
    <input type="text" id="node-input-inputTimeout" placeholder="speech timeout, in seconds">
    <input type="hidden" id="node-input-inputTimeoutType">
  </div>
  <div class="form-row">
    <label for="node-input-beep">Enable barge-in</label>
    <input type="checkbox" id="node-input-bargein">
  </div>
  <div class="form-row">
    <label for="node-input-passDtmf">Enable dtmf</label>
    <input type="checkbox" id="node-input-passDtmf">
  </div>
  <div class="form-row">
    <label for="node-input-eventHook">Event Hook</label>
    <input type="text" id="node-input-eventHook">
    <input type="hidden" id="node-input-eventHookType">
  </div>
  <div class="form-row">
    <label for="node-input-actionHook">Action Hook</label>
    <input type="text" id="node-input-actionHook">
    <input type="hidden" id="node-input-actionHookType">
  </div>
  <div class="form-row">
    <label for="node-input-prompt">Prompt audio</label>
    <select id="node-input-prompt">
      <option value="lex">Use Lex-provided audio</option>
      <option value="tts">Use text to speech</option>
    </select>
  </div>
  <div id="tts-options">
    <div class="form-row">
      <label for="node-input-vendor"> Vendor</label>
      <select id="node-input-vendor">
        <option value="default" selected>--application default--</option>
        <option value="google">google</option>
        <option value="aws">aws/polly</option>
      </select>
    </div>
    <div class="form-row" style="display: none;">
      <label for="node-input-lang"> Lang</label>
      <input type="text" id="node-input-lang">
    </div>
    <div class="form-row">
      <label for="node-input-xlang">Language</label>
      <select id="node-input-xlang">
        <option value="default" selected>--application default--</option>
      </select>
    </div>
    <div class="form-row" style="display: none;">
      <label for="node-input-voice"> Voice</label>
      <input type="text" id="node-input-voice">
    </div>
    <div class="form-row">
      <label for="node-input-xvoice">Voice</label>
      <select id="node-input-xvoice">
        <option value="default" selected>--application default--</option>
      </select>
    </div>
  </div>
</script>

<script type="text/html" data-help-name="pause">
  <p>Pause a specified number of seconds</p>
  <h3>Inputs</h3>
  <dl class="message-properties">
    <dt>Duration<span class="property-type">object</span></dt>
    <dd>Number of seconds pause</dd>
   </dl>

<h3>Outputs</h3>
<dl class="message-properties">
  <dt>jambonz<span class="property-type">object</span></dt>
  <dd> <code>msg.jambonz</code> will contain any previous actions provided to the input with the new <code>pause</code> action appended  </dd>
</dl>

<h3>Details</h3>
The pause verb waits a specified number of seconds before continuing to execute the application.
<h3>References</h3>
  <ul>
      <li><a href="https://docs.jambonz.org/jambonz/#pause">Jambonz pause reference</a></li>
  </ul>
</script>

<!-- listen -->
<script type="text/html" data-template-name="listen">
  <div class="form-row">
    <label for="node-input-name"><i class="icon-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name">
  </div>
  <div class="form-row">
    <label for="node-input-url">Url</label>
    <input type="text" id="node-input-url" placeholder="ws url">
    <input type="hidden" id="node-input-urlType">
  </div>
  <div class="form-row">
    <label for="node-input-authuser">User</label>
    <input type="text" id="node-input-authuser" placeholder="basic auth username">
    <input type="hidden" id="node-input-authuserType">
  </div>
  <div class="form-row">
    <label for="node-input-authpassword">Password</label>
    <input type="text" id="node-input-authpassword" placeholder="basic auth password">
    <input type="hidden" id="node-input-authpasswordType">
  </div>
  <div class="form-row">
    <label for="node-input-actionhook">Action hook</label>
    <input type="text" id="node-input-actionhook" placeholder="webhook url to invoke when operation ends">
    <input type="hidden" id="node-input-actionhookType">
  </div>
  <div class="form-row">
    <label for="node-input-metadata">Metadata</label>
    <input type="text" id="node-input-metadata">
    <input type="hidden" id="node-input-metadataType">
  </div>
  <div class="form-row">
    <label for="node-input-maxlength">Max duration</label>
    <input type="text" id="node-input-maxlength">
  </div>
  <div class="form-row">
    <label for="node-input-finishonkey">End key</label>
    <input type="text" id="node-input-finishonkey">
  </div>
  <div class="form-row">
    <label for="node-input-beep">Beep</label>
    <input type="checkbox" id="node-input-beep">
  </div>
  <div class="form-row">
    <label for="node-input-mixtype">Mix type</label>
    <select id="node-input-mixtype">
      <option selected>mono</option>
      <option>stereo</option>
    </select>
  </div>
  <div class="form-row">
    <label for="node-input-samplerate">Sample rate</label>
    <select id="node-input-samplerate">
      <option selected>8000</option>
      <option>16000</option>
      <option>24000</option>
      <option>48000</option>
      <option>64000</option>
    </select>
  </div>
  <fieldset>
    <legend>Transcription (optional)</legend>
    <div class="form-row">
      <label for="node-input-transcriptionhook"><i class="icon-tag"></i> Transcription hook</label>
      <input type="text" id="node-input-transcriptionhook" placeholder="transcription webhook">
      <input type="hidden" id="node-input-transcriptionhookType">
    </div>
    <div class="form-row">
      <label for="node-input-transcriptionvendor">Vendor</label>
      <select id="node-input-transcriptionvendor">
        <option value="default" selected>--application default--</option>
        <option value="google">Google</option>
        <option value="aws">AWS</option>
      </select>
    </div>
    <div class="form-row">
      <label for="node-input-recognizerlang"><i class="icon-tag"></i> Language</label>
      <select id="node-input-recognizerlang">
      </select>
    </div>
    <div id="interim" class="form-row">
      <label for="node-input-interim">Interim transcriptions</label>
      <input type="checkbox" id="node-input-interim">
    </div>
    <div id="stt-identify-channels" class="form-row">
      <label for="node-input-separaterecog">Separate recognition per channel</label>
      <input type="checkbox" id="node-input-separaterecog">
    </div>
    <div id="google-stt-options">
      <legend>Google Transcription Options</legend>
      <div class="form-row">
        <label for="node-input-transcriptionhints">Hints</label>
        <input type="text" id="node-input-transcriptionhints" placeholder="comma-separated list of phrases">
        <input type="hidden" id="node-input-transcriptionhintsType">
      </div>
      <div class="form-row">
        <label for="node-input-recognizeraltlang">Alternative languages</label>
        <input type="text" id="node-input-recognizeraltlang" placeholder="comma-separated list of add'l lang codes">
        <input type="hidden" id="node-input-recognizeraltlangType">
      </div>
      <div class="form-row">
        <label for="node-input-useenhanced">Use enhanced model</label>
        <input type="checkbox" id="node-input-useenhanced">
      </div>
      <div class="form-row">
        <label for="node-input-profanityfilter">Profanity filter</label>
        <input type="checkbox" id="node-input-profanityfilter">
      </div>
      <div class="form-row">
        <label for="node-input-words">Word time offsets</label>
        <input type="checkbox" id="node-input-words">
      </div>
      <div class="form-row">
        <label for="node-input-punctuation">Automatic punctuation</label>
        <input type="checkbox" id="node-input-punctuation">
      </div>
      <div class="form-row">
        <label for="node-input-diarization">Speaker diarization</label>
        <input type="checkbox" id="node-input-diarization">
      </div>
      <div class="form-row">
        <label for="node-input-diarizationmin">Min speaker count</label>
        <input type="text" id="node-input-diarizationmin" placeholder="2">
        <input type="hidden" id="node-input-diarizationminType">
      </div>
      <div class="form-row">
        <label for="node-input-diarizationmax">Max speaker count</label>
        <input type="text" id="node-input-diarizationmax" placeholder="6">
        <input type="hidden" id="node-input-diarizationmaxType">
      </div>    
      <div class="form-row">
        <label for="node-input-interactiontype">Type of Interaction</label>
        <select id="node-input-interactiontype">
          <option value="unspecified" selected>Unspecified</option>
          <option value="discussion">Discusssion</option>
          <option value="presentation">Presentation</option>
          <option value="phone_call">Phone call</option>
          <option value="voicemail">Voicemail</option>
          <option value="voice_search">Voice search</option>
          <option value="voice_command">Voice command</option>
          <option value="dictation">Dictation</option>
        </select>
      </div>
      <div class="form-row">
        <label for="node-input-naics">Industry NAICS code</label>
        <input type="text" id="node-input-naics">
        <input type="hidden" id="node-input-naicsType">
      </div>
    </div>
    <div id="aws-stt-options">
      <legend>AWS Transcription Options</legend>
      <div class="form-row">
        <label for="node-input-identifychannels">Enable channel identification</label>
        <input type="checkbox" id="node-input-identifychannels">
      </div>
      <div class="form-row">
        <label for="node-input-speakerlabel">Show speaker labels</label>
        <input type="checkbox" id="node-input-speakerlabel">
      </div>
      <div class="form-row">
        <label for="node-input-vocabularyname">Vocabulary name</label>
        <input type="text" id="node-input-vocabularyname">
        <input type="hidden" id="node-input-vocabularynameType">
      </div>
      <div class="form-row">
        <label for="node-input-vocabularyfiltername">Vocabulary filter name</label>
        <input type="text" id="node-input-vocabularyfiltername">
        <input type="hidden" id="node-input-vocabularyfilternameType">
      </div>
      <div class="form-row">
        <label for="node-input-vocabularyfiltermethod">Filter method</label>
        <select id="node-input-vocabularyfiltermethod">
          <option value="remove" selected>Remove</option>
          <option value="mask" selected>Mask</option>
          <option value="tag" selected>Tag</option>
        </select>
      </div>
    </div>
  </fieldset>

</script>

<script type="text/html" data-help-name="listen">
  <p>send live audio for the call to an over a websocket connection</p>
  <h3>Inputs</h3>
  <dl class="message-properties">
    <dt>ws url<span class="property-type">string</span></dt>
    <dd>url of remote server to connect to	</dd>
    <dt>User<span class="property-type">string</span></dt>
    <dd>Username for HTTP Basic Auth</dd>
    <dt>Password<span class="property-type">string</span></dt>
    <dd>Password for HTTP Basic Auth</dd>
    <dt>Action hook<span class="property-type">string</span></dt>
    <dd>webhook to invoke when listen operation ends</dd>
    <dt>Metadata<span class="property-type">json</span></dt>
    <dd>arbitrary data to add to the JSON payload sent to the remote server when websocket connection is first connected</dd>
    <dt>Max duration<span class="property-type">number</span></dt>
    <dd>the maximum length of the listened audio stream, in secs</dd>
    <dt>End key<span class="property-type">string</span></dt>
    <dd>The set of digits that can end the listen action</dd>
    <dt>Beep<span class="property-type">string</span></dt>
    <dd>if checked, play a beep at the start of the listen operation</dd>
    <dt>Mix type<span class="property-type">string</span></dt>
    <dd>whether to record a mono or stereo stream</dd>
    <dt>Sample rate<span class="property-type">number</span></dt>
    <dd>Sample rate of audio to stream</dd>
    <dt>Transcription hook<span class="property-type">string</span></dt>
    <dd>webhook to call when a transcription is received</dd>
    <dt>Language<span class="property-type">string</span></dt>
    <dd>Language to use for transcription</dd>
    <dt>Send interim transcriptions<span class="property-type">boolean</span></dt>
    <dd>if checked, send interim transcriptions</dd>
    <dt>Profanity filter<span class="property-type">boolean</span></dt>
    <dd>if checked, enable profanity filtering</dd>

</dl>

<h3>Outputs</h3>
<dl class="message-properties">
   <dt>jambonz<span class="property-type">object</span></dt>
   <dd> <code>msg.jambonz</code> will contain any previous actions provided to the input with the new <code>listen</code> action appended  </dd>
</dl>

<h3>Details</h3>
The listen verb establishes a connection to a websocket server and sends live audio for the current call.<h3>References</h3>
  <ul>
      <li><a href="https://docs.jambonz.org/jambonz/#listen">Jambonz listen reference</a></li>
  </ul>
</script>

<!-- message -->
<script type="text/html" data-template-name="message">
  <div class="form-row">
    <label for="node-input-name"><i class="icon-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name">
  </div>
  <div class="form-row">
    <label for="node-input-from">From</label>
    <input type="text" id="node-input-from" placeholder="sending number">
    <input type="hidden" id="node-input-fromType">
  </div>
  <div class="form-row">
    <label for="node-input-to">To</label>
    <input type="text" id="node-input-to" placeholder="destination number">
    <input type="hidden" id="node-input-toType">
  </div>
  <div class="form-row">
    <label for="node-input-text">Text</label>
    <input type="text" id="node-input-text" placeholder="Text">
    <input type="hidden" id="node-input-textType">
  </div>
  <div class="form-row">
    <label for="node-input-provider">SMS Provider</label>
    <input type="text" id="node-input-provider">
    <input type="hidden" id="node-input-providerType">
  </div>  
</script>

<script type="text/html" data-help-name="message">
  <p>Send an SMS</p>
  <h3>Inputs</h3>
  <dl class="message-properties">

  </dl>

<h3>Outputs</h3>
<dl class="message-properties">
   <dt>jambonz<span class="property-type">object</span></dt>
   <dd> <code>msg.jambonz</code> will contain any previous actions provided to the input with the new <code>message</code> action appended  </dd>
</dl>

<h3>Details</h3>
The message verb sends an SMS message.
<h3>References</h3>
  <ul>
      <li><a href="https://docs.jambonz.org/jambonz/#message">Jambonz redirect reference</a></li>
  </ul>
</script>
<!-- pause -->
<script type="text/html" data-template-name="pause">
  <div class="form-row">
    <label for="node-input-name"><i class="icon-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name">
  </div>
  <div class="form-row">
    <label for="node-input-length">Duration</label>
    <input type="text" id="node-input-len" placeholder="number of seconds to pause">
    <input type="hidden" id="node-input-lenType">
  </div>
</script>

<script type="text/html" data-help-name="pause">
  <p>Pause a specified number of seconds</p>
  <h3>Inputs</h3>
  <dl class="message-properties">
    <dt>Duration<span class="property-type">object</span></dt>
    <dd>Number of seconds pause</dd>
   </dl>

<h3>Outputs</h3>
<dl class="message-properties">
  <dt>jambonz<span class="property-type">object</span></dt>
  <dd> <code>msg.jambonz</code> will contain any previous actions provided to the input with the new <code>pause</code> action appended  </dd>
</dl>

<h3>Details</h3>
The pause verb waits a specified number of seconds before continuing to execute the application.
<h3>References</h3>
  <ul>
      <li><a href="https://docs.jambonz.org/jambonz/#pause">Jambonz pause reference</a></li>
  </ul>
</script>

<!-- play -->
<script type="text/html" data-template-name="play">
  <div class="form-row">
    <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name">
  </div>
  <div class="form-row">
    <label for="node-input-url">Url</label>
    <input type="text" id="node-input-url" placeholder="url returning .mp3 or .wav file">
    <input type="hidden" id="node-input-urlType">
  </div>
  <div class="form-row">
    <label for="node-input-early"><i class="icon-tag"></i>Early media</label>
    <input type="checkbox" id="node-input-early">
  </div>
  <div class="form-row">
    <label for="node-input-loop"><i class="icon-tag"></i>Loop</label>
    <input type="input" id="node-input-loop" placeholder="number of times to repeat"> 
  </div>  
</script>

<script type="text/html" data-help-name="play">
  <p>Play a wav or mp3 file</p>
  <h3>Inputs</h3>
  <dl class="message-properties">
    <dt>Url<span class="property-type">string</span></dt>
    <dd>a single url or array of urls (will play in sequence) to a wav or mp3 file</dd>
    <dt>Early media<span class="property-type">boolean</span></dt>
    <dd>if checked, play the url over an early media connection</dd>
    <dt>Loop<span class="property-type">number</span></dt>
    <dd>number of times to play the url</dd>
</dl>

<h3>Outputs</h3>
<dl class="message-properties">
   <dt>jambonz<span class="property-type">object</span></dt>
   <dd> <code>msg.jambonz</code> will contain any previous actions provided to the input with the new <code>play</code> action appended  </dd>
</dl>

<h3>Details</h3>
The play action plays an mp3 or wave file into a call.  If early media is checked, the audio will be played over an early media connection, 
if the call has not already been answered.

<h3>References</h3>
  <ul>
      <li><a href="https://docs.jambonz.org/jambonz/#play">Jambonz play reference</a></li>
  </ul>
</script>

<!-- redirect -->
<script type="text/html" data-template-name="redirect">
  <div class="form-row">
    <label for="node-input-name"><i class="icon-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name">
  </div>
  <div class="form-row">
    <label for="node-input-hook">Action hook</label>
    <input type="text" id="node-input-hook" placeholder="url">
    <input type="hidden" id="node-input-hookType">
  </div>
</script>

<script type="text/html" data-help-name="redirect">
  <p>Redirect a call to a new application URL</p>
  <h3>Inputs</h3>
  <dl class="message-properties">
      <dt>Action hook<span class="property-type">string</span></dt>
      <dd>URL of webhook to retrieve new application from.</dd>
  </dl>

<h3>Outputs</h3>
<dl class="message-properties">
   <dt>jambonz<span class="property-type">object</span></dt>
   <dd> <code>msg.jambonz</code> will contain any previous actions provided to the input with the new <code>redirect</code> action appended  </dd>
</dl>

<h3>Details</h3>
The redirect verb retrieves a new URL to execute for the current call.
<h3>References</h3>
  <ul>
      <li><a href="https://docs.jambonz.org/jambonz/#redirect">Jambonz redirect reference</a></li>
  </ul>
</script>

<!-- say -->
<script type="text/html" data-template-name="say">
  <div class="form-row">
    <label for="node-input-name"><i class="icon-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name">
</div>
<div class="form-row">
  <label for="node-input-text"><i class="icon-tag"></i> Text</label>
  <textarea id="node-input-text" rows="4" placeholder="Text or SSML to speak" style="width:70%"></textarea>
</div>
<div class="form-row">
  <label for="node-input-early"><i class="icon-tag"></i>Early media</label>
  <input type="checkbox" id="node-input-early">
</div>
<div class="form-row">
  <label for="node-input-loop"><i class="icon-tag"></i>Loop</label>
  <input type="input" id="node-input-loop" placeholder="number of times to repeat"> 
</div>
<fieldset>
  <legend>Speech synthesis options</legend>
  <div class="form-row">
    <label for="node-input-vendor">Vendor</label>
    <select id="node-input-vendor">
      <option value="default" selected>--application default--</option>
      <option value="google">google</option>
      <option value="aws">aws/polly</option>
    </select>
  </div>
  <div class="form-row" style="display: none;">
    <label for="node-input-lang"> Lang</label>
    <input type="text" id="node-input-lang">
  </div>
  <div class="form-row">
    <label for="node-input-xlang">Language</label>
    <select id="node-input-xlang">
      <option value="default" selected>--application default--</option>
    </select>
  </div>
  <div class="form-row" style="display: none;">
    <label for="node-input-voice"> Voice</label>
    <input type="text" id="node-input-voice">
  </div>
  <div class="form-row">
    <label for="node-input-xvoice">Voice</label>
    <select id="node-input-xvoice">
      <option value="default" selected>--application default--</option>
    </select>
  </div>
</fieldset>
</script>

<script type="text/html" data-help-name="say">
  <p>Synthesize speech from text or SSML</p>
  <h3>Inputs</h3>
  <dl class="message-properties">
    <dt>Text<span class="property-type">string</span></dt>
    <dd>text to speak; may contain SSML tags</dd>
    <dt>Early media<span class="property-type">boolean</span></dt>
    <dd>if checked, play the prompt over an early media connection</dd>
    <dt>Loop<span class="property-type">number</span></dt>
    <dd>number of times to play the prompt</dd>
    <dt>Vendor<span class="property-type">string</span></dt>
    <dd>TTS vendor</dd>
    <dt>Language<span class="property-type">string</span></dt>
    <dd>TTS language</dd>
    <dt>Voice<span class="property-type">string</span></dt>
    <dd>TTS voice</dd>
  </dl>

<h3>Outputs</h3>
<dl class="message-properties">
   <dt>jambonz<span class="property-type">object</span></dt>
   <dd> <code>msg.jambonz</code> will contain any previous actions provided to the input with the new <code>say</code> action appended  </dd>
</dl>

<h3>Details</h3>
The say command is used to send synthesized speech to the remote party. 
The text provided may be either plain text or may use SSML tags.
<h3>References</h3>
  <ul>
      <li><a href="https://docs.jambonz.org/jambonz/#say">Jambonz say reference</a></li>
</script>

<!-- sip:decline -->
<script type="text/html" data-template-name="sip:decline">
  <div class="form-row">
    <label for="node-input-name"><i class="icon-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name">
  </div>
  <div class="form-row">
    <label for="node-input-status">Status</label>
    <input type="text" id="node-input-status" placeholder="SIP status code">
    <input type="hidden" id="node-input-statusType">
  </div>
  <div class="form-row">
    <label for="node-input-reason">Reason</label>
    <input type="text" id="node-input-reason" placeholder="sip reason">
    <input type="hidden" id="node-input-reasonType">
  </div>
</script>

<script type="text/html" data-help-name="sip:decline">
  <p>Reject an incoming call with a status code and, optionally, reason</p>
  <h3>Inputs</h3>
  <dl class="message-properties">
    <dt>SIP status code<span class="property-type">number</span></dt>
    <dd>A valid SIP status code in the range 4XX - 6XX</dd>
    <dt>Reason<span class="property-type">string</span></dt>
    <dd>A brief description</dd>
</dl>

<h3>Outputs</h3>
<dl class="message-properties">
   <dt>jambonz<span class="property-type">object</span></dt>
   <dd> <code>msg.jambonz</code> will contain any previous actions provided to the input with the new <code>sip:decline</code> action appended  </dd>
</dl>

<h3>Details</h3>
The sip:decline verb rejects an incoming call.
<h3>References</h3>
  <ul>
      <li><a href="https://docs.jambonz.org/jambonz/#sipdecline">Jambonz sip:decline reference</a></li>
  </ul>
</script>

<!-- tag -->
<script type="text/html" data-template-name="tag">
  <div class="form-row">
    <label for="node-input-name"><i class="icon-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name">
  </div>
  <div class="form-row">
    <label for="node-input-length">Data</label>
    <input type="text" id="node-input-data" placeholder="data object">
    <input type="hidden" id="node-input-dataType">
  </div>
</script>

<script type="text/html" data-help-name="tag">
  <p>Add additional metadata to a call</p>
  <h3>Inputs</h3>
  <dl class="message-properties">
      <dt>Data<span class="property-type">json</span></dt>
      <dd>A JSON object containing values to be saved and included in future action or call status notifications.</dd>
  </dl>

  <h3>Outputs</h3>
  <dl class="message-properties">
    <dt>jambonz<span class="property-type">object</span></dt>
    <dd> <code>msg.jambonz</code> will contain any previous actions provided to the input with the new <code>tag</code> action appended  </dd>
  </dl>

  <h3>Details</h3>
  The tag verb is used to add properties to the standard call attributes that jambonz includes on every action or call status HTTP POST request.<h3>References</h3>
  <ul>
      <li><a href="https://docs.jambonz.org/jambonz/#tag">Jambonz tag reference</a></li>
  </ul>
</script>

<!-- dialogflow -->
<script type="text/html" data-template-name="dialogflow">
  <div class="form-row">
    <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name">
  </div>
  <div class="form-row">
    <label for="node-input-project">Dialogflow project ID</label>
    <input type="text" id="node-input-project">
    <input type="hidden" id="node-input-projectType">
  </div>
  <div class="form-row">
    <label for="node-input-project">Environment</label>
    <input type="text" id="node-input-environment">
    <input type="hidden" id="node-input-enviromentType">
  </div>
  <div class="form-row">
    <label for="node-input-recognizerlang">Speaker language</label>
    <select id="node-input-recognizerlang">
      <option value="placeholder"></option>
    </select>
  </div>
  <div class="form-row">
    <label for="node-input-serviceAccountCredentials">Service account key</label>
    <input type="text" id="node-input-serviceAccountCredentials">
    <input type="hidden" id="node-input-serviceAccountCredentialsType">
  </div>
  <div class="form-row">
    <label for="node-input-welcomeEvent">Welcome intent</label>
    <input type="text" id="node-input-welcomeEvent" placeholder="event to send on connect">
    <input type="hidden" id="node-input-welcomeEventType">
  </div>
  <div class="form-row">
    <label for="node-input-welcomeEventParams">Welcome intent parameters</label>
    <input type="text" id="node-input-welcomeEventParams">
    <input type="hidden" id="node-input-welcomeEventParamsType">
  </div>
  <div class="form-row">
    <label for="node-input-inputTimeout">Input timeout</label>
    <input type="text" id="node-input-inputTimeout" placeholder="seconds to wait for a response">
    <input type="hidden" id="node-input-inputTimeoutType">
  </div>
  <div class="form-row">
    <label for="node-input-noInputEvent">Input timeout intent</label>
    <input type="text" id="node-input-noInputEvent" placeholder="event to send on input timeout">
    <input type="hidden" id="node-input-noInputEventType">
  </div>
  <div class="form-row">
    <label for="node-input-bargein">Barge in on speech?</label>
    <input type="checkbox" id="node-input-bargein">
  </div>
  <div class="form-row">
    <label for="node-input-eventHook">Event Hook</label>
    <input type="text" id="node-input-eventHook">
    <input type="hidden" id="node-input-eventHookType">
  </div>
  <div class="form-row">
    <label for="node-input-actionHook">Action Hook</label>
    <input type="text" id="node-input-actionHook">
    <input type="hidden" id="node-input-actionHookType">
  </div>
  <div class="form-row">
    <label for="node-input-prompt">Prompt audio</label>
    <select id="node-input-prompt" style="width:250px;">
      <option value="dialogflow">Use dialogflow-provided audio</option>
      <option value="tts">Use text to speech</option>
    </select>
  </div>
  <div id="tts-options">
    <div class="form-row">
      <label for="node-input-vendor"> Vendor</label>
      <select id="node-input-vendor">
        <option value="default" selected>--application default--</option>
        <option value="google">google</option>
        <option value="aws">aws/polly</option>
      </select>
    </div>
    <div class="form-row" style="display: none;">
      <label for="node-input-lang"> Lang</label>
      <input type="text" id="node-input-lang">
    </div>
    <div class="form-row">
      <label for="node-input-xlang">Language</label>
      <select id="node-input-xlang">
        <option value="default" selected>--application default--</option>
      </select>
    </div>
    <div class="form-row" style="display: none;">
      <label for="node-input-voice"> Voice</label>
      <input type="text" id="node-input-voice">
    </div>
    <div class="form-row">
      <label for="node-input-xvoice">Voice</label>
      <select id="node-input-xvoice">
        <option value="default" selected>--application default--</option>
      </select>
    </div>
  </div>
</script>

<script type="text/html" data-help-name="dialogflow">
  <p>Run a Google dialogflow bot on the call</p>
  <h3>Inputs</h3>
  <dl class="message-properties">
    <dt>Dialogflow Project ID<span class="property-type">string</span></dt>
    <dd> The name of the dialogflow project to execute. Required.</dd>
    <dt>Service Account Key<span class="property-type">string</span></dt>
    <dd> A Google service account key in JSON format is used to authenticate to dialogflow. Required.</dd>
    <dt>Language<span class="property-type">string</span></dt>
    <dd> The ISO language code to use for speech recognition. Required.</dd>
    <dt>Welcome Intent<span class="property-type">string</span></dt>
    <dd> The name of a dialogflow intent to send when the call is first connected. Optional.</dd>
    <dt>Welcome Intent Parameters<span class="property-type">object</span></dt>
    <dd> A JSON object containing parameters to send along with the welcome intent. Optional.</dd>
    <dt>Input Timeout<span class="property-type">number</span></dt>
    <dd> Number of seconds to wait for no response.  Optional.</dd>
    <dt>Event Hook<span class="property-type">number</span></dt>
    <dd> Webhook to call when an intent, transcription or other dialogflow event is received. Optional.</dd>
    <dt>Action Hook<span class="property-type">number</span></dt>
    <dd> Webhook to call when the dialogflow bot interaction concludes. Optional.</dd>
</dl>

  <h3>Outputs</h3>
  <dl class="message-properties">
    <dt>jambonz<span class="property-type">object</span></dt>
    <dd> <code>msg.jambonz</code> will contain any previous actions provided to the input with the new <code>dialogflow</code> action appended  </dd>
  </dl>

  <h3>Details</h3>
  The dialogflow action connects the call to a Google dialogflow voicebot.  
  The action completes either when a new application is returned in a response to an eventHook, or the call is terminated from the dialogflow side.

  <h3>References</h3>
    <ul>
        <li><a href="https://docs.jambonz.org/jambonz/#dialogflow">Jambonz dialogflow reference</a></li>
    </ul>
</script>

<!-- api-token config node -->
<script type="text/html" data-template-name="jambonz_auth">
  <div class="form-row">
    <label for="node-config-input-url">Base URL</label>
    <input type="text" id="node-config-input-url" placeholder="http://localhost:3000">
</div>
<div class="form-row">
  <label for="node-config-input-accountSid">AccountSid</label>
  <input type="text" id="node-config-input-accountSid">
</div>
<div class="form-row">
  <label for="node-config-input-apiToken">API token</label>
  <input type="text" id="node-config-input-apiToken">
</div>
<div class="form-row">
  <button id="btn-test-credentials"><i class="fa fa-lock"></i> Test Credentials</button>
  <span id="node-config-test-status" style="margin-left: 20px;"></span>
</div>
</script>

<script type="text/x-red" data-help-name="jambonz_auth">
  <p>Creates a new jambonz server credential </p>
  <h3>Details</h3>
  <p>Enter the base url of the server, along with your API key</p>
</script>

<!-- aws config node -->
<script type="text/html" data-template-name="aws_auth">
  <div class="form-row">
    <label for="node-config-input-accessKey">AWS Access Key ID</label>
    <input type="text" id="node-config-input-accessKey">
  </div>
  <div class="form-row">
    <label for="node-config-input-secretAccessKey">AWS Secret Access Key</label>
    <input type="text" id="node-config-input-secretAccessKey">
  </div>
</script>

<script type="text/x-red" data-help-name="jambonz_auth">
  <p>AWS access key and secret access key to use for Lex</p>
  <h3>Details</h3>
  <p>Enter the AWS access key and secret access key</p>
</script>


<!-- LCC -->
<script type="text/html" data-template-name="lcc">
  <div class="form-row">
    <label for="node-input-name"><i class="icon-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name">
</div>
<div class="form-row">
  <label for="node-input-server">Server</label>
  <input type="text" id="node-input-server">
</div>
<div class="form-row">
  <label for="node-input-callSid">CallSid</label>
  <input type="text" id="node-input-callSid">
  <input type="hidden" id="node-input-callSidType">
</div>
<div class="form-row">
  <label for="node-input-action">Action</label>
  <select id="node-input-action">
    <option value="hangup">hangup call</option>
    <option value="mute">mute caller</option>
    <option value="unmute">unmute caller</option>
    <option value="mute_conf">mute conference participants</option>
    <option value="unmute_conf">unmute conference participants</option>
    <option value="hold_conf">hold conference participant</option>
    <option value="unhold_conf">unhold conference participant</option>
    <option value="pause">pause listen audio feed</option>
    <option value="resume">resume listen audio feed</option>
    <option value="redirect">redirect call</option>
    <option value="whisper">whisper</option>
  </select>
</div>
<div id="say-options">
  <div class="form-row">
    <label for="node-input-text">Text</label>
    <textarea id="node-input-text" rows="4" placeholder="Text or SSML to whisper" style="width:70%"></textarea>
  </div>
  <fieldset>
    <legend>Speech synthesis options</legend>
    <div class="form-row">
      <label for="node-input-vendor">Vendor</label>
      <select id="node-input-vendor">
        <option value="default" selected>--application default--</option>
        <option value="google">google</option>
        <option value="aws">aws/polly</option>
      </select>
    </div>
    <div class="form-row">
      <label for="node-input-lang">Language</label>
      <select id="node-input-lang">
        <option value="default" selected>--application default--</option>
      </select>
    </div>
    <div class="form-row">
      <label for="node-input-voice">Voice</label>
      <select id="node-input-voice">
        <option value="default" selected>--application default--</option>
      </select>
    </div>
  </fieldset>
</div>
<div id="redirect-options">
  <div class="form-row">
    <label for="node-input-callHook">Call webhook</label>
    <input type="text" id="node-input-callHook" placeholder="/path">
    <input type="hidden" id="node-input-callHookType">
  </div>  
</div>
<div id="wait-options">
  <div class="form-row">
    <label for="node-input-waitHook">Wait webhook</label>
    <input type="text" id="node-input-waitHook" placeholder="/path">
    <input type="hidden" id="node-input-waitHookType">
  </div>  
</div>
</script>

<script type="text/html" data-help-name="lcc">
  <p>Perform Live Call Control</p>
  <h3>Inputs</h3>
  <dl class="message-properties">
    <dt>Server<span class="property-type">config</span></dt>
    <dd>jambonz server to connect to</dd>
    <dt>CallSid<span class="property-type">string</span></dt>
    <dd>Call identifier</dd>
    <dt>Action<span class="property-type">string</span></dt>
    <dd>Action to perform on the call</dd>
    <dt>Text<span class="property-type">string</span></dt>
    <dd>Text to speak, only if action is 'whisper'</dd>
    <dt>Vendor<span class="property-type">string</span></dt>
    <dd>TTS vendor to use for whisper</dd>
    <dt>Language<span class="property-type">string</span></dt>
    <dd>TTS language to use for whisper</dd>
    <dt>Voice<span class="property-type">string</span></dt>
    <dd>TTS voice to use for whisper</dd>
  </dl>

<h3>Details</h3>
The lcc command is used to perform live call control on a call in progress.
The call can be terminated, the caller can be muted or unmuted, or the live 
audio feed that is being sent via a <a href="https://docs.jambonz.org/jambonz/#listen">listen</a> verb can be paused or resumed.
<br/><br/>
A common use case is to use dtmf captures in a <a href="https://docs.jambonz.org/jambonz/#dial">dial</a> verb to call a webhook 
that then uses lcc to modify the state of the call.
<h3>References</h3>
  <ul>
      <li><a href="https://docs.jambonz.org/rest/#updating-a-call">Jambonz reference</a></li>
</script>

<!-- Create call -->
<script type="text/html" data-template-name="create-call">
  <div class="form-row">
    <label for="node-input-name"><i class="icon-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name">
</div>
<div class="form-row">
  <label for="node-input-server">Server</label>
  <input type="text" id="node-input-server">
</div>
<div class="form-row">
  <label for="node-input-from">From</label>
  <input type="text" id="node-input-from" placeholder="calling party number">
  <input type="hidden" id="node-input-fromType">
</div>
<div class="form-row">
  <label for="node-input-to">To</label>
  <input type="text" id="node-input-to" placeholder="called party info">
  <input type="hidden" id="node-input-toType">
</div>
<div class="form-row">
  <label for="node-input-dest">Call type</label>
  <select id="node-input-dest">
    <option value="phone">phone number</option>
    <option value="user">registered sip device/user</option>
    <option value="sip">sip endpoint</option>
    <option value="ms-teams">Microsoft teams</option>
  </select>
</div>
<div class="form-row">
  <label for="node-input-timeout">Ring timeout</label>
  <input type="text" id="node-input-timeout" placeholder="ring no answer timeout in secs (default: 60)">
  <input type="hidden" id="node-input-timeoutType">
</div>
<div class="form-row">
  <label for="node-input-application">Application</label>
  <select id="node-input-application">
  </select>
</div>

</script>

<script type="text/html" data-help-name="create-call">
  <p>Create an outbound call</p>
  <h3>Inputs</h3>
  <dl class="message-properties">
    <dt>Server<span class="property-type">config</span></dt>
    <dd>jambonz server to connect to</dd>
    <dt>From<span class="property-type">string</span></dt>
    <dd>Calling party phone number</dd>
    <dt>To<span class="property-type">string</span></dt>
    <dd>Called party phone number, or other identifier</dd>
    <dt>Call type<span class="property-type">string</span></dt>
    <dd>Type of destination: phone number, registered user, sip endpoint, or microsoft teams</dd>
    <dt>Application<span class="property-type">string</span></dt>
    <dd>Application to execute when call is answered</dd>
  </dl>

<h3>Details</h3>
The create call command is used to generate a new outbound call.  
When the call is answered the specified application's call hook will be invoked.
<h3>References</h3>
  <ul>
      <li><a href="https://docs.jambonz.org/rest/#create-a-call">Jambonz reference</a></li>
  </ul>
</script>

<!-- Create sms -->
<script type="text/html" data-template-name="create-sms">
  <div class="form-row">
    <label for="node-input-name"><i class="icon-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name">
  </div>
<div class="form-row">
  <label for="node-input-server">Server</label>
  <input type="text" id="node-input-server">
</div>
<div class="form-row">
  <label for="node-input-from">From</label>
  <input type="text" id="node-input-from" placeholder="sending number">
  <input type="hidden" id="node-input-fromType">
</div>
<div class="form-row">
  <label for="node-input-to">To</label>
  <input type="text" id="node-input-to" placeholder="destination number">
  <input type="hidden" id="node-input-toType">
</div>
<div class="form-row">
  <label for="node-input-text">Text</label>
  <input type="text" id="node-input-text" placeholder="Text">
  <input type="hidden" id="node-input-textType">
</div>
<div class="form-row">
  <label for="node-input-provider">SMS Provider</label>
  <input type="text" id="node-input-provider">
  <input type="hidden" id="node-input-providerType">
</div>
</script>

<script type="text/html" data-help-name="create-sms">
  <p>Send an SMS</p>
  <h3>Inputs</h3>
  <dl class="message-properties">
    <dt>Server<span class="property-type">config</span></dt>
    <dd>jambonz server to connect to</dd>
    <dt>From<span class="property-type">string</span></dt>
    <dd>Sending party phone number</dd>
    <dt>To<span class="property-type">string</span></dt>
    <dd>Destination phone number</dd>
    <dt>Text<span class="property-type">string</span></dt>
    <dd>Text message</dd>
  </dl>

<h3>Details</h3>
The create message command is used to send an SMS message.  
<!--
<h3>References</h3>
  <ul>
      <li><a href="https://docs.jambonz.org/rest/#create-a-call">Jambonz reference</a></li>
  </ul>
-->
</script>
